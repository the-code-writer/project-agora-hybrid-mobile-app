import { getTablesNames } from '../utils/utils-drop';
import { getTableColumnNamesTypes } from '../utils/utils-json';
export const beginTransaction = async (db, isOpen) => {
  const msg = 'BeginTransaction: ';
  if (!isOpen) {
    return Promise.reject(new Error(`${msg}database not opened`));
  }
  const sql = 'BEGIN TRANSACTION;';
  try {
    await db.run(sql);
    return Promise.resolve();
  }
  catch (err) {
    return Promise.reject(new Error(`DbChanges failed: ${err}`));
  }
};
export const rollbackTransaction = async (db, isOpen) => {
  const msg = 'RollbackTransaction: ';
  if (!isOpen) {
    return Promise.reject(new Error(`${msg}database not opened`));
  }
  const sql = 'ROLLBACK TRANSACTION;';
  try {
    await db.run(sql);
    return Promise.resolve();
  }
  catch (err) {
    return Promise.reject(new Error(`${msg}${err.message}`));
  }
};
export const commitTransaction = async (db, isOpen) => {
  const msg = 'CommitTransaction: ';
  if (!isOpen) {
    return Promise.reject(new Error(`${msg}database not opened`));
  }
  const sql = 'COMMIT TRANSACTION;';
  try {
    await db.run(sql);
    return Promise.resolve();
  }
  catch (err) {
    return Promise.reject(new Error(`${msg}${err.message}`));
  }
};
export const dbChanges = async (db) => {
  const SELECT_CHANGE = 'SELECT total_changes()';
  let changes = 0;
  try {
    const res = await db.exec(SELECT_CHANGE);
    // process the row here
    changes = res[0].values[0][0];
    return Promise.resolve(changes);
  }
  catch (err) {
    return Promise.reject(new Error(`DbChanges failed: ${err.message}`));
  }
};
export const getLastId = async (db) => {
  const SELECT_LAST_ID = 'SELECT last_insert_rowid()';
  let lastId = -1;
  try {
    const res = await db.exec(SELECT_LAST_ID);
    // process the row here
    lastId = res[0].values[0][0];
    return Promise.resolve(lastId);
  }
  catch (err) {
    return Promise.reject(new Error(`GetLastId failed: ${err.message}`));
  }
};
export const setForeignKeyConstraintsEnabled = async (db, toggle) => {
  let key = 'OFF';
  if (toggle) {
    key = 'ON';
  }
  try {
    await db.exec(`PRAGMA foreign_keys = '${key}'`);
    return Promise.resolve();
  }
  catch (err) {
    return Promise.reject(new Error(`SetForeignKey: ${err.message}`));
  }
};
export const getVersion = async (db) => {
  let version = 0;
  try {
    const res = await db.exec('PRAGMA user_version;');
    version = res[0].values[0][0];
    return Promise.resolve(version);
  }
  catch (err) {
    return Promise.reject(new Error(`GetVersion: ${err.message}`));
  }
};
export const setVersion = async (db, version) => {
  try {
    await db.exec(`PRAGMA user_version = ${version}`);
    return Promise.resolve();
  }
  catch (err) {
    return Promise.reject(new Error(`SetVersion: ${err.message}`));
  }
};
export const execute = async (db, sql, fromJson) => {
  let changes = -1;
  let initChanges = -1;
  try {
    initChanges = await dbChanges(db);
    var sqlStmt = sql;
    // Check for DELETE FROM in sql string
    if (!fromJson && sql.toLowerCase().includes('DELETE FROM'.toLowerCase())) {
      sqlStmt = sql.replace(/\n/g, '');
      let sqlStmts = sqlStmt.split(';');
      var resArr = [];
      for (const stmt of sqlStmts) {
        const trimStmt = stmt.trim().substring(0, 11).toUpperCase();
        if (trimStmt === 'DELETE FROM' && stmt.toLowerCase().includes('WHERE'.toLowerCase())) {
          const whereStmt = stmt.trim();
          const rStmt = await deleteSQL(db, whereStmt, []);
          resArr.push(rStmt);
        }
        else {
          resArr.push(stmt);
        }
      }
      sqlStmt = resArr.join(';');
    }
    await db.exec(sqlStmt);
    changes = (await dbChanges(db)) - initChanges;
    return Promise.resolve(changes);
  }
  catch (err) {
    return Promise.reject(new Error(`Execute: ${err.message}`));
  }
};
export const executeSet = async (db, set, fromJson) => {
  let lastId = -1;
  for (let i = 0; i < set.length; i++) {
    const statement = 'statement' in set[i] ? set[i].statement : null;
    const values = 'values' in set[i] && set[i].values.length > 0 ? set[i].values : [];
    if (statement == null) {
      let msg = 'ExecuteSet: Error No statement';
      msg += ` for index ${i}`;
      return Promise.reject(new Error(msg));
    }
    try {
      if (Array.isArray(values[0])) {
        for (const val of values) {
          const mVal = await replaceUndefinedByNull(val);
          await run(db, statement, mVal, fromJson);
          //          await db.exec(statement, mVal);
        }
      }
      else {
        const mVal = await replaceUndefinedByNull(values);
        await run(db, statement, mVal, fromJson);
        //        await db.exec(statement, mVal);
      }
      lastId = await getLastId(db);
    }
    catch (err) {
      return Promise.reject(new Error(`ExecuteSet: ${err.message}`));
    }
  }
  return Promise.resolve(lastId);
};
export const queryAll = async (db, sql, values) => {
  const result = [];
  try {
    let retArr = [];
    if (values != null && values.length > 0) {
      retArr = await db.exec(sql, values);
    }
    else {
      retArr = await db.exec(sql);
    }
    if (retArr.length == 0)
      return Promise.resolve([]);
    for (const valRow of retArr[0].values) {
      const row = {};
      for (let i = 0; i < retArr[0].columns.length; i++) {
        row[retArr[0].columns[i]] = valRow[i];
      }
      result.push(row);
    }
    return Promise.resolve(result);
  }
  catch (err) {
    return Promise.reject(new Error(`queryAll: ${err.message}`));
  }
};
export const run = async (db, statement, values, fromJson) => {
  let stmtType = statement.replace(/\n/g, "").trim().substring(0, 6).toUpperCase();
  let lastId = -1;
  let sqlStmt = statement;
  try {
    if (!fromJson && stmtType === "DELETE") {
      sqlStmt = await deleteSQL(db, statement, values);
    }
    if (values != null && values.length > 0) {
      const mVal = await replaceUndefinedByNull(values);
      await db.exec(sqlStmt, mVal);
    }
    else {
      await db.exec(sqlStmt);
    }
    lastId = await getLastId(db);
    return Promise.resolve(lastId);
  }
  catch (err) {
    return Promise.reject(new Error(`run: ${err.message}`));
  }
};
export const deleteSQL = async (db, statement, values) => {
  let sqlStmt = statement;
  try {
    const isLast = await isLastModified(db, true);
    const isDel = await isSqlDeleted(db, true);
    if (isLast && isDel) {
      // Replace DELETE by UPDATE and set sql_deleted to 1
      const wIdx = statement.toUpperCase().indexOf("WHERE");
      const preStmt = statement.substring(0, wIdx - 1);
      const clauseStmt = statement.substring(wIdx, statement.length);
      const tableName = preStmt.substring(("DELETE FROM").length).trim();
      sqlStmt = `UPDATE ${tableName} SET sql_deleted = 1 ${clauseStmt}`;
      // Find REFERENCES if any and update the sql_deleted column
      await findReferencesAndUpdate(db, tableName, clauseStmt, values);
    }
    return Promise.resolve(sqlStmt);
  }
  catch (err) {
    return Promise.reject(new Error(`deleteSQL: ${err.message}`));
  }
};
export const findReferencesAndUpdate = async (db, tableName, whereStmt, values) => {
  try {
    const references = await getReferences(db, tableName);
    for (const refe of references) {
      // get the tableName of the reference
      const refTable = await getReferenceTableName(refe.sql);
      if (refTable.length <= 0) {
        continue;
      }
      // get the columnName
      const colName = await getReferenceColumnName(refe.sql);
      if (colName.length <= 0) {
        continue;
      }
      // update the where clause
      const uWhereStmt = await updateWhere(whereStmt, colName);
      if (uWhereStmt.length <= 0) {
        continue;
      }
      //update sql_deleted for this reference
      const stmt = "UPDATE " + refTable + " SET sql_deleted = 1 " + uWhereStmt;
      if (values != null && values.length > 0) {
        const mVal = await replaceUndefinedByNull(values);
        await db.exec(stmt, mVal);
      }
      else {
        await db.exec(stmt);
      }
      const lastId = await getLastId(db);
      if (lastId == -1) {
        const msg = `UPDATE sql_deleted failed for references table: ${refTable}`;
        return Promise.reject(new Error(`findReferencesAndUpdate: ${msg}`));
      }
      return;
    }
  }
  catch (err) {
    return Promise.reject(new Error(`findReferencesAndUpdate: ${err.message}`));
  }
};
export const getReferenceTableName = async (refValue) => {
  var tableName = '';
  if (refValue.length > 0 && refValue.substring(0, 12).toLowerCase() === 'CREATE TABLE'.toLowerCase()) {
    const oPar = refValue.indexOf("(");
    tableName = refValue.substring(13, oPar).trim();
  }
  return tableName;
};
export const getReferenceColumnName = async (refValue) => {
  var colName = '';
  if (refValue.length > 0) {
    const index = refValue.toLowerCase().indexOf("FOREIGN KEY".toLowerCase());
    const stmt = refValue.substring(index + 12);
    const oPar = stmt.indexOf("(");
    const cPar = stmt.indexOf(")");
    colName = stmt.substring(oPar + 1, cPar).trim();
  }
  return colName;
};
export const updateWhere = async (whStmt, colName) => {
  var whereStmt = '';
  if (whStmt.length > 0) {
    const index = whStmt.toLowerCase().indexOf("WHERE".toLowerCase());
    const stmt = whStmt.substring(index + 6);
    const fEqual = stmt.indexOf("=");
    const whereColName = stmt.substring(0, fEqual).trim();
    whereStmt = whStmt.replace(whereColName, colName);
  }
  return whereStmt;
};
export const getReferences = async (db, tableName) => {
  const sqlStmt = "SELECT sql FROM sqlite_master " +
    "WHERE sql LIKE('%REFERENCES%') AND " +
    "sql LIKE('%" +
    tableName +
    "%') AND sql LIKE('%ON DELETE%');";
  try {
    const res = await queryAll(db, sqlStmt, []);
    return Promise.resolve(res);
  }
  catch (err) {
    return Promise.reject(new Error(`getReferences: ${err.message}`));
  }
};
export const getTableList = async (db) => {
  try {
    const result = await getTablesNames(db);
    return Promise.resolve(result);
  }
  catch (err) {
    return Promise.reject(new Error(`getTableList: ${err.message}`));
  }
};
export const isTableExists = async (db, tableName) => {
  try {
    let statement = 'SELECT name FROM sqlite_master WHERE ';
    statement += `type='table' AND name='${tableName}';`;
    const res = await queryAll(db, statement, []);
    const ret = res.length > 0 ? true : false;
    return Promise.resolve(ret);
  }
  catch (err) {
    return Promise.reject(new Error(`isTableExists: ${err.message}`));
  }
};
/**
 * isLastModified
 * @param db
 * @param isOpen
 */
export const isLastModified = async (db, isOpen) => {
  if (!isOpen) {
    return Promise.reject('isLastModified: database not opened');
  }
  try {
    const tableList = await getTablesNames(db);
    for (const table of tableList) {
      const tableNamesTypes = await getTableColumnNamesTypes(db, table);
      const tableColumnNames = tableNamesTypes.names;
      if (tableColumnNames.includes("last_modified")) {
        return Promise.resolve(true);
      }
    }
  }
  catch (err) {
    return Promise.reject(`isLastModified: ${err}`);
  }
};
/**
 * isSqlDeleted
 * @param db
 * @param isOpen
 */
export const isSqlDeleted = async (db, isOpen) => {
  if (!isOpen) {
    return Promise.reject('isSqlDeleted: database not opened');
  }
  try {
    const tableList = await getTablesNames(db);
    for (const table of tableList) {
      const tableNamesTypes = await getTableColumnNamesTypes(db, table);
      const tableColumnNames = tableNamesTypes.names;
      if (tableColumnNames.includes("sql_deleted")) {
        return Promise.resolve(true);
      }
    }
  }
  catch (err) {
    return Promise.reject(`isSqlDeleted: ${err}`);
  }
};
export const replaceUndefinedByNull = async (values) => {
  const retValues = [];
  for (const val of values) {
    let mVal = val;
    if (typeof val === 'undefined')
      mVal = null;
    retValues.push(mVal);
  }
  return Promise.resolve(retValues);
};
export const backupTables = async (db) => {
  const msg = 'BackupTables: ';
  let alterTables = {};
  try {
    const tables = await getTablesNames(db);
    for (const table of tables) {
      try {
        const colNames = await backupTable(db, table);
        alterTables[`${table}`] = colNames;
      }
      catch (err) {
        return Promise.reject(new Error(`${msg}table ${table}: ` + `${err.message}`));
      }
    }
    return Promise.resolve(alterTables);
  }
  catch (err) {
    return Promise.reject(new Error(`BackupTables: ${err.message}`));
  }
};
export const backupTable = async (db, table) => {
  try {
    // start a transaction
    await beginTransaction(db, true);
    // get the table's column names
    const colNames = await getTableColumnNames(db, table);
    const tmpTable = `_temp_${table}`;
    // Drop the tmpTable if exists
    const delStmt = `DROP TABLE IF EXISTS ${tmpTable};`;
    await run(db, delStmt, [], false);
    // prefix the table with _temp_
    let stmt = `ALTER TABLE ${table} RENAME `;
    stmt += `TO ${tmpTable};`;
    const lastId = await run(db, stmt, [], false);
    if (lastId < 0) {
      let msg = 'BackupTable: lastId < 0';
      try {
        await rollbackTransaction(db, true);
      }
      catch (err) {
        msg += `: ${err.message}`;
      }
      return Promise.reject(new Error(`${msg}`));
    }
    else {
      try {
        await commitTransaction(db, true);
        return Promise.resolve(colNames);
      }
      catch (err) {
        return Promise.reject(new Error('BackupTable: ' + `${err.message}`));
      }
    }
  }
  catch (err) {
    return Promise.reject(new Error(`BackupTable: ${err.message}`));
  }
};
export const getTableColumnNames = async (db, tableName) => {
  let resQuery = [];
  const retNames = [];
  const query = `PRAGMA table_info('${tableName}');`;
  try {
    resQuery = await queryAll(db, query, []);
    if (resQuery.length > 0) {
      for (const query of resQuery) {
        retNames.push(query.name);
      }
    }
    return Promise.resolve(retNames);
  }
  catch (err) {
    return Promise.reject(new Error('GetTableColumnNames: ' + `${err.message}`));
  }
};
export const findCommonColumns = async (db, alterTables) => {
  let commonColumns = {};
  try {
    // Get new table list
    const tables = await getTablesNames(db);
    if (tables.length === 0) {
      return Promise.reject(new Error('FindCommonColumns: get ' + "table's names failed"));
    }
    for (const table of tables) {
      // get the column's name
      const tableNames = await getTableColumnNames(db, table);
      // find the common columns
      const keys = Object.keys(alterTables);
      if (keys.includes(table)) {
        commonColumns[table] = arraysIntersection(alterTables[table], tableNames);
      }
    }
    return Promise.resolve(commonColumns);
  }
  catch (err) {
    return Promise.reject(new Error(`FindCommonColumns: ${err.message}`));
  }
};
const arraysIntersection = (a1, a2) => {
  if (a1 != null && a2 != null) {
    const first = new Set(a1);
    const second = new Set(a2);
    return [...first].filter(item => second.has(item));
  }
  else {
    return [];
  }
};
export const updateNewTablesData = async (db, commonColumns) => {
  try {
    // start a transaction
    await beginTransaction(db, true);
    const statements = [];
    const keys = Object.keys(commonColumns);
    keys.forEach(key => {
      const columns = commonColumns[key].join(',');
      let stmt = `INSERT INTO ${key} `;
      stmt += `(${columns}) `;
      stmt += `SELECT ${columns} FROM _temp_${key};`;
      statements.push(stmt);
    });
    const changes = await execute(db, statements.join('\n'), false);
    if (changes < 0) {
      let msg = 'updateNewTablesData: ' + 'changes < 0';
      try {
        await rollbackTransaction(db, true);
      }
      catch (err) {
        msg += `: ${err.message}`;
      }
      return Promise.reject(new Error(`${msg}`));
    }
    else {
      try {
        await commitTransaction(db, true);
        return Promise.resolve();
      }
      catch (err) {
        return Promise.reject(new Error('updateNewTablesData: ' + `${err.message}`));
      }
    }
  }
  catch (err) {
    return Promise.reject(new Error('updateNewTablesData: ' + `${err.message}`));
  }
};
//# sourceMappingURL=utils-sqlite.js.map