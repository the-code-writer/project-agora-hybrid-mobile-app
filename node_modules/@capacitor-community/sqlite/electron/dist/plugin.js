'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var require$$0 = require('sqlite3');
var require$$0$1 = require('path');
var require$$1 = require('fs');
var require$$2 = require('os');
var require$$3 = require('jszip');
var require$$4 = require('electron');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var require$$0__default = /*#__PURE__*/_interopDefaultLegacy(require$$0);
var require$$0__default$1 = /*#__PURE__*/_interopDefaultLegacy(require$$0$1);
var require$$1__default = /*#__PURE__*/_interopDefaultLegacy(require$$1);
var require$$2__default = /*#__PURE__*/_interopDefaultLegacy(require$$2);
var require$$3__default = /*#__PURE__*/_interopDefaultLegacy(require$$3);
var require$$4__default = /*#__PURE__*/_interopDefaultLegacy(require$$4);

var src = {};

var Database$1 = {};

var exportToJson = {};

var utilsSQLite = {};

Object.defineProperty(utilsSQLite, "__esModule", { value: true });
utilsSQLite.UtilsSQLite = void 0;
class UtilsSQLite {
    constructor() {
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        //    this.JSQlite = require('@journeyapps/sqlcipher').verbose();
        this.SQLite3 = require$$0__default['default'];
    }
    /**
     * OpenOrCreateDatabase
     * @param pathDB
     * @param password
     */
    async openOrCreateDatabase(pathDB /*,
    password: string,*/) {
        const msg = 'OpenOrCreateDatabase: ';
        // open sqlite3 database
        /*    const mDB: any = new this.JSQlite.Database(pathDB, {
          verbose: console.log,
        });
        */
        const mDB = new this.SQLite3.Database(pathDB, {
            verbose: console.log,
        });
        if (mDB != null) {
            try {
                await this.dbChanges(mDB);
            }
            catch (err) {
                return Promise.reject(msg + `dbChanges ${err}`);
            }
            try {
                /*        // set the password
                if (password.length > 0) {
                  await this.setCipherPragma(mDB, password);
                }
        */
                // set Foreign Keys On
                await this.setForeignKeyConstraintsEnabled(mDB, true);
                // Check Version
                const curVersion = await this.getVersion(mDB);
                if (curVersion === 0) {
                    await this.setVersion(mDB, 1);
                }
            }
            catch (err) {
                return Promise.reject(msg + `${err}`);
            }
            return Promise.resolve(mDB);
        }
        else {
            return Promise.reject(msg + 'open database failed');
        }
    }
    /**
     * SetCipherPragma
     * @param mDB
     * @param password
     */
    /*
    public async setCipherPragma(mDB: any, password: string): Promise<void> {
      return new Promise((resolve, reject) => {
        mDB.serialize(() => {
          mDB.run('PRAGMA cipher_compatibility = 4');
          mDB.run(`PRAGMA key = '${password}'`, (err: any) => {
            if (err) {
              reject(new Error('SetForeignKey: ' + `${err.message}`));
            }
            resolve();
          });
        });
      });
    }
  */
    /**
     * SetForeignKeyConstraintsEnabled
     * @param mDB
     * @param toggle
     */
    async setForeignKeyConstraintsEnabled(mDB, toggle) {
        return new Promise((resolve, reject) => {
            let key = 'OFF';
            if (toggle) {
                key = 'ON';
            }
            mDB.run(`PRAGMA foreign_keys = '${key}'`, (err) => {
                if (err) {
                    reject(`SetForeignKey: ${err.message}`);
                }
                resolve();
            });
        });
    }
    /**
     * GetVersion
     * @param mDB
     */
    async getVersion(mDB) {
        return new Promise((resolve, reject) => {
            let version = 0;
            const SELECT_VERSION = 'PRAGMA user_version;';
            mDB.get(SELECT_VERSION, [], (err, row) => {
                // process the row here
                if (err) {
                    reject('getVersion failed: ' + `${err.message}`);
                }
                else {
                    if (row == null) {
                        version = 0;
                    }
                    else {
                        const key = Object.keys(row)[0];
                        version = row[key];
                    }
                    resolve(version);
                }
            });
        });
    }
    /**
     * SetVersion
     * @param mDB
     * @param version
     */
    async setVersion(mDB, version) {
        return new Promise((resolve, reject) => {
            mDB.run(`PRAGMA user_version = ${version}`, (err) => {
                if (err) {
                    reject('setVersion failed: ' + `${err.message}`);
                }
                resolve();
            });
        });
    }
    /**
     * ChangePassword
     * @param pathDB
     * @param password
     * @param newpassword
     */
    /*
  
    public async changePassword(
      pathDB: string,
      password: string,
      newpassword: string,
    ): Promise<void> {
      let mDB: any;
      try {
        mDB = await this.openOrCreateDatabase(pathDB, password);
        await this.pragmaReKey(mDB, password, newpassword);
      } catch (err) {
        return Promise.reject(err);
      } finally {
        mDB.close();
      }
    }
  */
    /**
     * PragmaReKey
     * @param mDB
     * @param password
     * @param newpassword
     */
    /*
    private async pragmaReKey(
      mDB: any,
      password: string,
      newpassword: string,
    ): Promise<void> {
      return new Promise((resolve, reject) => {
        mDB.serialize(() => {
          mDB.run('PRAGMA cipher_compatibility = 4');
          mDB.run(`PRAGMA key = '${password}'`);
          mDB.run(`PRAGMA rekey = '${newpassword}'`, (err: any) => {
            if (err) {
              reject(new Error('ChangePassword: ' + `${err.message}`));
            }
            resolve();
          });
        });
      });
    }
  */
    /**
     * BeginTransaction
     * @param db
     * @param isOpen
     */
    async beginTransaction(db, isOpen) {
        return new Promise((resolve, reject) => {
            const msg = 'BeginTransaction: ';
            if (!isOpen) {
                return Promise.reject(`${msg}database not opened`);
            }
            const sql = 'BEGIN TRANSACTION;';
            db.run(sql, (err) => {
                if (err) {
                    reject(`${msg}${err.message}`);
                }
                resolve();
            });
        });
    }
    /**
     * RollbackTransaction
     * @param db
     * @param isOpen
     */
    async rollbackTransaction(db, isOpen) {
        return new Promise((resolve, reject) => {
            const msg = 'RollbackTransaction: ';
            if (!isOpen) {
                reject(`${msg}database not opened`);
            }
            const sql = 'ROLLBACK TRANSACTION;';
            db.run(sql, (err) => {
                if (err) {
                    reject(`${msg}${err.message}`);
                }
                resolve();
            });
        });
    }
    /**
     * CommitTransaction
     * @param db
     * @param isOpen
     */
    async commitTransaction(db, isOpen) {
        return new Promise((resolve, reject) => {
            const msg = 'CommitTransaction: ';
            if (!isOpen) {
                reject(`${msg}database not opened`);
            }
            const sql = 'COMMIT TRANSACTION;';
            db.run(sql, (err) => {
                if (err) {
                    reject(`${msg}${err.message}`);
                }
                resolve();
            });
        });
    }
    /**
     * DbChanges
     * return total number of changes
     * @param db
     */
    async dbChanges(db) {
        return new Promise((resolve, reject) => {
            const SELECT_CHANGE = 'SELECT total_changes()';
            let changes = 0;
            db.get(SELECT_CHANGE, [], (err, row) => {
                // process the row here
                if (err) {
                    reject(`DbChanges failed: ${err.message}`);
                }
                else {
                    if (row == null) {
                        changes = 0;
                    }
                    else {
                        const key = Object.keys(row)[0];
                        changes = row[key];
                    }
                    resolve(changes);
                }
            });
        });
    }
    /**
     * GetLastId
     * @param db
     */
    getLastId(db) {
        return new Promise((resolve, reject) => {
            const SELECT_LAST_ID = 'SELECT last_insert_rowid()';
            let lastId = -1;
            db.get(SELECT_LAST_ID, [], (err, row) => {
                // process the row here
                if (err) {
                    reject(`GetLastId failed: ${err.message}`);
                }
                else {
                    if (row == null)
                        resolve(lastId);
                    const key = Object.keys(row)[0];
                    lastId = row[key];
                    resolve(lastId);
                }
            });
        });
    }
    /**
     * Execute
     * @param mDB
     * @param sql
     */
    async execute(mDB, sql, fromJson) {
        let changes = -1;
        let initChanges = -1;
        try {
            initChanges = await this.dbChanges(mDB);
            let sqlStmt = sql;
            // Check for DELETE FROM in sql string
            if (!fromJson &&
                sql.toLowerCase().includes('DELETE FROM'.toLowerCase())) {
                sqlStmt = sql.replace(/\n/g, '');
                const sqlStmts = sqlStmt.split(';');
                const resArr = [];
                for (const stmt of sqlStmts) {
                    const trimStmt = stmt.trim().substring(0, 11).toUpperCase();
                    if (trimStmt === 'DELETE FROM' &&
                        stmt.toLowerCase().includes('WHERE'.toLowerCase())) {
                        const whereStmt = `${stmt.trim()};`;
                        const rStmt = await this.deleteSQL(mDB, whereStmt, []);
                        resArr.push(rStmt);
                    }
                    else {
                        resArr.push(stmt);
                    }
                }
                sqlStmt = resArr.join(';');
            }
            await this.execDB(mDB, sqlStmt);
            changes = (await this.dbChanges(mDB)) - initChanges;
            return Promise.resolve(changes);
        }
        catch (err) {
            return Promise.reject(`Execute: ${err.message}`);
        }
    }
    /**
     * ExecDB
     * @param mDB
     * @param sql
     */
    async execDB(mDB, sql) {
        return new Promise((resolve, reject) => {
            mDB.exec(sql, async (err) => {
                if (err) {
                    reject(`Execute: ${err.message}: `);
                }
                resolve();
            });
        });
    }
    /**
     * ExecuteSet
     * @param db
     * @param set
     */
    async executeSet(db, set, fromJson) {
        let lastId = -1;
        for (let i = 0; i < set.length; i++) {
            const statement = 'statement' in set[i] ? set[i].statement : null;
            const values = 'values' in set[i] && set[i].values.length > 0 ? set[i].values : [];
            if (statement == null) {
                let msg = 'ExecuteSet: Error Nostatement';
                msg += ` for index ${i}`;
                return Promise.reject(msg);
            }
            try {
                if (Array.isArray(values[0])) {
                    for (const val of values) {
                        const mVal = await this.replaceUndefinedByNull(val);
                        lastId = await this.prepareRun(db, statement, mVal, fromJson);
                    }
                }
                else {
                    const mVal = await this.replaceUndefinedByNull(values);
                    lastId = await this.prepareRun(db, statement, mVal, fromJson);
                }
            }
            catch (err) {
                return Promise.reject(`ExecuteSet: ${err}`);
            }
        }
        return Promise.resolve(lastId);
    }
    /**
     * PrepareRun
     * @param db
     * @param statement
     * @param values
     */
    async prepareRun(db, statement, values, fromJson) {
        const stmtType = statement
            .replace(/\n/g, '')
            .trim()
            .substring(0, 6)
            .toUpperCase();
        let sqlStmt = statement;
        let lastId = -1;
        try {
            if (!fromJson && stmtType === 'DELETE') {
                sqlStmt = await this.deleteSQL(db, statement, values);
            }
            let mVal = [];
            if (values != null && values.length > 0) {
                mVal = await this.replaceUndefinedByNull(values);
            }
            await this.runExec(db, sqlStmt, mVal);
            lastId = await this.getLastId(db);
            return Promise.resolve(lastId);
        }
        catch (err) {
            return Promise.reject(`PrepareRun: ${err}`);
        }
    }
    async runExec(db, stmt, values = []) {
        return new Promise((resolve, reject) => {
            if (values != null && values.length > 0) {
                db.run(stmt, values, (err) => {
                    if (err) {
                        reject(err.message);
                    }
                    else {
                        resolve();
                    }
                });
            }
            else {
                db.exec(stmt, (err) => {
                    if (err) {
                        reject(err.message);
                    }
                    else {
                        resolve();
                    }
                });
            }
        });
    }
    /**
     * replaceUndefinedByNull
     * @param values
     * @returns
     */
    async replaceUndefinedByNull(values) {
        const retValues = [];
        if (values.length > 0) {
            for (const val of values) {
                let mVal = val;
                if (typeof val === 'undefined')
                    mVal = null;
                retValues.push(mVal);
            }
        }
        return Promise.resolve(retValues);
    }
    /**
     * deleteSQL
     * @param db
     * @param statement
     * @param values
     * @returns
     */
    async deleteSQL(db, statement, values) {
        let sqlStmt = statement;
        try {
            const isLast = await this.isLastModified(db, true);
            const isDel = await this.isSqlDeleted(db, true);
            if (isLast && isDel) {
                // Replace DELETE by UPDATE and set sql_deleted to 1
                const wIdx = statement.toUpperCase().indexOf('WHERE');
                const preStmt = statement.substring(0, wIdx - 1);
                const clauseStmt = statement.substring(wIdx, statement.length);
                const tableName = preStmt
                    .substring('DELETE FROM'.length)
                    .trim();
                sqlStmt = `UPDATE ${tableName} SET sql_deleted = 1 ${clauseStmt}`;
                // Find REFERENCES if any and update the sql_deleted column
                await this.findReferencesAndUpdate(db, tableName, clauseStmt, values);
            }
            return sqlStmt;
        }
        catch (err) {
            return Promise.reject(`DeleteSL: ${err}`);
        }
    }
    /**
     * findReferencesAndUpdate
     * @param db
     * @param tableName
     * @param whereStmt
     * @param values
     * @returns
     */
    async findReferencesAndUpdate(db, tableName, whereStmt, values) {
        try {
            const references = await this.getReferences(db, tableName);
            for (const refe of references) {
                // get the tableName of the reference
                const refTable = await this.getReferenceTableName(refe.sql);
                if (refTable.length <= 0) {
                    continue;
                }
                // get the columnName
                const colName = await this.getReferenceColumnName(refe.sql);
                if (colName.length <= 0) {
                    continue;
                }
                // update the where clause
                const uWhereStmt = await this.updateWhere(whereStmt, colName);
                if (uWhereStmt.length <= 0) {
                    continue;
                }
                //update sql_deleted for this reference
                const stmt = `UPDATE ${refTable} SET sql_deleted = 1 ${uWhereStmt}`;
                if (values != null && values.length > 0) {
                    const mVal = await this.replaceUndefinedByNull(values);
                    await db.run(stmt, mVal);
                }
                else {
                    await db.exec(stmt);
                }
                const lastId = await this.getLastId(db);
                if (lastId == -1) {
                    const msg = `UPDATE sql_deleted failed for references table: ${refTable}`;
                    return Promise.reject(new Error(`findReferencesAndUpdate: ${msg}`));
                }
            }
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(new Error(`findReferencesAndUpdate: ${err.message}`));
        }
    }
    async getReferenceTableName(refValue) {
        let tableName = '';
        if (refValue.length > 0 &&
            refValue.substring(0, 12).toLowerCase() === 'CREATE TABLE'.toLowerCase()) {
            const oPar = refValue.indexOf('(');
            tableName = refValue.substring(13, oPar).trim();
        }
        return tableName;
    }
    async getReferenceColumnName(refValue) {
        let colName = '';
        if (refValue.length > 0) {
            const index = refValue
                .toLowerCase()
                .indexOf('FOREIGN KEY'.toLowerCase());
            const stmt = refValue.substring(index + 12);
            const oPar = stmt.indexOf('(');
            const cPar = stmt.indexOf(')');
            colName = stmt.substring(oPar + 1, cPar).trim();
        }
        return colName;
    }
    async updateWhere(whStmt, colName) {
        let whereStmt = '';
        if (whStmt.length > 0) {
            const index = whStmt.toLowerCase().indexOf('WHERE'.toLowerCase());
            const stmt = whStmt.substring(index + 6);
            const fEqual = stmt.indexOf('=');
            const whereColName = stmt.substring(0, fEqual).trim();
            whereStmt = whStmt.replace(whereColName, colName);
        }
        return whereStmt;
    }
    async getReferences(db, tableName) {
        const sqlStmt = 'SELECT sql FROM sqlite_master ' +
            "WHERE sql LIKE('%REFERENCES%') AND " +
            "sql LIKE('%" +
            tableName +
            "%') AND sql LIKE('%ON DELETE%');";
        try {
            const res = await this.queryAll(db, sqlStmt, []);
            return Promise.resolve(res);
        }
        catch (err) {
            return Promise.reject(new Error(`getReferences: ${err.message}`));
        }
    }
    /**
     * QueryAll
     * @param mDB
     * @param sql
     * @param values
     */
    queryAll(mDB, sql, values) {
        return new Promise((resolve, reject) => {
            mDB.serialize(() => {
                mDB.all(sql, values, (err, rows) => {
                    if (err) {
                        reject(`QueryAll: ${err.message}`);
                    }
                    else {
                        if (rows == null) {
                            rows = [];
                        }
                        resolve(rows);
                    }
                });
            });
        });
    }
    /**
     * GetTablesNames
     * @param mDb
     */
    async getTablesNames(mDb) {
        let sql = 'SELECT name FROM sqlite_master WHERE ';
        sql += "type='table' AND name NOT LIKE 'sync_table' ";
        sql += "AND name NOT LIKE '_temp_%' ";
        sql += "AND name NOT LIKE 'sqlite_%' ";
        sql += 'ORDER BY rootpage DESC;';
        const retArr = [];
        try {
            const retQuery = await this.queryAll(mDb, sql, []);
            for (const query of retQuery) {
                retArr.push(query.name);
            }
            return Promise.resolve(retArr);
        }
        catch (err) {
            return Promise.reject(`getTablesNames: ${err}`);
        }
    }
    /**
     * GetViewsNames
     * @param mDb
     */
    async getViewsNames(mDb) {
        let sql = 'SELECT name FROM sqlite_master WHERE ';
        sql += "type='view' AND name NOT LIKE 'sqlite_%' ";
        sql += 'ORDER BY rootpage DESC;';
        const retArr = [];
        try {
            const retQuery = await this.queryAll(mDb, sql, []);
            for (const query of retQuery) {
                retArr.push(query.name);
            }
            return Promise.resolve(retArr);
        }
        catch (err) {
            return Promise.reject(`getViewsNames: ${err}`);
        }
    }
    /**
     * isLastModified
     * @param db
     * @param isOpen
     */
    async isLastModified(db, isOpen) {
        if (!isOpen) {
            return Promise.reject('isLastModified: database not opened');
        }
        try {
            const tableList = await this.getTablesNames(db);
            for (const table of tableList) {
                const tableNamesTypes = await this.getTableColumnNamesTypes(db, table);
                const tableColumnNames = tableNamesTypes.names;
                if (tableColumnNames.includes('last_modified')) {
                    return Promise.resolve(true);
                }
            }
        }
        catch (err) {
            return Promise.reject(`isLastModified: ${err}`);
        }
    }
    /**
     * isSqlDeleted
     * @param db
     * @param isOpen
     */
    async isSqlDeleted(db, isOpen) {
        if (!isOpen) {
            return Promise.reject('isSqlDeleted: database not opened');
        }
        try {
            const tableList = await this.getTablesNames(db);
            for (const table of tableList) {
                const tableNamesTypes = await this.getTableColumnNamesTypes(db, table);
                const tableColumnNames = tableNamesTypes.names;
                if (tableColumnNames.includes('sql_deleted')) {
                    return Promise.resolve(true);
                }
            }
        }
        catch (err) {
            return Promise.reject(`isSqlDeleted: ${err}`);
        }
    }
    /**
     * GetTableColumnNamesTypes
     * @param mDB
     * @param tableName
     */
    async getTableColumnNamesTypes(mDB, tableName) {
        let resQuery = [];
        const retNames = [];
        const retTypes = [];
        const query = `PRAGMA table_info('${tableName}');`;
        try {
            resQuery = await this.queryAll(mDB, query, []);
            if (resQuery.length > 0) {
                for (const query of resQuery) {
                    retNames.push(query.name);
                    retTypes.push(query.type);
                }
            }
            return Promise.resolve({ names: retNames, types: retTypes });
        }
        catch (err) {
            return Promise.reject('GetTableColumnNamesTypes: ' + `${err}`);
        }
    }
}
utilsSQLite.UtilsSQLite = UtilsSQLite;

var utilsJson = {};

Object.defineProperty(utilsJson, "__esModule", { value: true });
utilsJson.UtilsJson = void 0;
const utilsSQLite_1$5 = utilsSQLite;
class UtilsJson {
    constructor() {
        this.sqliteUtil = new utilsSQLite_1$5.UtilsSQLite();
    }
    /**
     * IsTableExists
     * @param db
     * @param isOpen
     * @param tableName
     */
    async isTableExists(db, isOpen, tableName) {
        return new Promise((resolve, reject) => {
            if (!isOpen) {
                reject('isTableExists: database not opened');
            }
            let query = 'SELECT name FROM sqlite_master WHERE ';
            query += `type='table' AND name='${tableName}';`;
            db.all(query, [], (err, rows) => {
                // process the row here
                if (err) {
                    reject(`isTableExists: failed: ${err.message}`);
                }
                else {
                    if (rows.length === 0) {
                        resolve(false);
                    }
                    else {
                        resolve(true);
                    }
                }
            });
        });
    }
    /**
     * IsViewExists
     * @param db
     * @param isOpen
     * @param viewName
     */
    async isViewExists(db, isOpen, viewName) {
        return new Promise((resolve, reject) => {
            if (!isOpen) {
                reject('isViewExists: database not opened');
            }
            let query = 'SELECT name FROM sqlite_master WHERE ';
            query += `type='view' AND name='${viewName}';`;
            db.all(query, [], (err, rows) => {
                // process the row here
                if (err) {
                    reject(`isViewExists: failed: ${err.message}`);
                }
                else {
                    if (rows.length === 0) {
                        resolve(false);
                    }
                    else {
                        resolve(true);
                    }
                }
            });
        });
    }
    /**
     * CreateSchema
     * @param mDB
     * @param jsonData
     */
    async createSchema(mDB, jsonData) {
        // create the database schema
        let changes = 0;
        try {
            // start a transaction
            await this.sqliteUtil.beginTransaction(mDB, true);
        }
        catch (err) {
            return Promise.reject(`CreateDatabaseSchema: ${err}`);
        }
        const stmts = await this.createSchemaStatement(jsonData);
        if (stmts.length > 0) {
            const schemaStmt = stmts.join('\n');
            try {
                changes = await this.sqliteUtil.execute(mDB, schemaStmt, true);
                if (changes < 0) {
                    try {
                        await this.sqliteUtil.rollbackTransaction(mDB, true);
                    }
                    catch (err) {
                        return Promise.reject('CreateSchema: changes < 0 ' + `${err}`);
                    }
                }
            }
            catch (err) {
                const msg = err;
                try {
                    await this.sqliteUtil.rollbackTransaction(mDB, true);
                    return Promise.reject(`CreateSchema: ${msg}`);
                }
                catch (err) {
                    return Promise.reject('CreateSchema: changes < 0 ' + `${err}: ${msg}`);
                }
            }
        }
        try {
            await this.sqliteUtil.commitTransaction(mDB, true);
            return Promise.resolve(changes);
        }
        catch (err) {
            return Promise.reject('CreateSchema: commit ' + `${err}`);
        }
    }
    /**
     * CreateSchemaStatement
     * @param jsonData
     */
    async createSchemaStatement(jsonData) {
        const statements = [];
        let isLastModified = false;
        let isSqlDeleted = false;
        // Prepare the statement to execute
        try {
            for (const jTable of jsonData.tables) {
                if (jTable.schema != null && jTable.schema.length >= 1) {
                    // create table
                    statements.push('CREATE TABLE IF NOT EXISTS ' + `${jTable.name} (`);
                    for (let j = 0; j < jTable.schema.length; j++) {
                        if (j === jTable.schema.length - 1) {
                            if (jTable.schema[j].column) {
                                statements.push(`${jTable.schema[j].column} ${jTable.schema[j].value}`);
                                if (jTable.schema[j].column === 'last_modified') {
                                    isLastModified = true;
                                }
                                if (jTable.schema[j].column === 'sql_deleted') {
                                    isSqlDeleted = true;
                                }
                            }
                            else if (jTable.schema[j].foreignkey) {
                                statements.push(`FOREIGN KEY (${jTable.schema[j].foreignkey}) ${jTable.schema[j].value}`);
                            }
                            else if (jTable.schema[j].constraint) {
                                statements.push(`CONSTRAINT ${jTable.schema[j].constraint} ${jTable.schema[j].value}`);
                            }
                        }
                        else {
                            if (jTable.schema[j].column) {
                                statements.push(`${jTable.schema[j].column} ${jTable.schema[j].value},`);
                                if (jTable.schema[j].column === 'last_modified') {
                                    isLastModified = true;
                                }
                                if (jTable.schema[j].column === 'sql_deleted') {
                                    isSqlDeleted = true;
                                }
                            }
                            else if (jTable.schema[j].foreignkey) {
                                statements.push(`FOREIGN KEY (${jTable.schema[j].foreignkey}) ${jTable.schema[j].value},`);
                            }
                            else if (jTable.schema[j].constraint) {
                                statements.push(`CONSTRAINT ${jTable.schema[j].constraint} ${jTable.schema[j].value},`);
                            }
                        }
                    }
                    statements.push(');');
                    if (isLastModified && isSqlDeleted) {
                        // create trigger last_modified associated with the table
                        let trig = 'CREATE TRIGGER IF NOT EXISTS ';
                        trig += `${jTable.name}`;
                        trig += `_trigger_last_modified `;
                        trig += `AFTER UPDATE ON ${jTable.name} `;
                        trig += 'FOR EACH ROW WHEN NEW.last_modified < ';
                        trig += 'OLD.last_modified BEGIN UPDATE ';
                        trig += `${jTable.name} `;
                        trig += `SET last_modified = `;
                        trig += "(strftime('%s','now')) WHERE id=OLD.id; END;";
                        statements.push(trig);
                    }
                }
                if (jTable.indexes != null && jTable.indexes.length >= 1) {
                    for (const jIndex of jTable.indexes) {
                        const tableName = jTable.name;
                        let stmt = `CREATE ${Object.keys(jIndex).includes('mode') ? jIndex.mode + ' ' : ''} INDEX IF NOT EXISTS `;
                        stmt += `${jIndex.name} ON ${tableName} (${jIndex.value});`;
                        statements.push(stmt);
                    }
                }
                if (jTable.triggers != null && jTable.triggers.length >= 1) {
                    for (const jTrg of jTable.triggers) {
                        const tableName = jTable.name;
                        if (jTrg.timeevent.toUpperCase().endsWith(' ON')) {
                            jTrg.timeevent = jTrg.timeevent.substring(0, jTrg.timeevent.length - 3);
                        }
                        let stmt = `CREATE TRIGGER IF NOT EXISTS `;
                        stmt += `${jTrg.name} ${jTrg.timeevent} ON ${tableName} `;
                        if (jTrg.condition)
                            stmt += `${jTrg.condition} `;
                        stmt += `${jTrg.logic};`;
                        statements.push(stmt);
                    }
                }
            }
            return Promise.resolve(statements);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    /**
     * CreateDataTable
     * @param mDB
     * @param table
     * @param mode
     */
    async createDataTable(mDB, table, mode) {
        let lastId = -1;
        try {
            // Check if the table exists
            const tableExists = await this.isTableExists(mDB, true, table.name);
            if (!tableExists) {
                return Promise.reject('CreateDataTable: Table ' + `${table.name} does not exist`);
            }
            // Get the column names and types
            const tableNamesTypes = await this.sqliteUtil.getTableColumnNamesTypes(mDB, table.name);
            const tableColumnTypes = tableNamesTypes.types;
            const tableColumnNames = tableNamesTypes.names;
            if (tableColumnTypes.length === 0) {
                return Promise.reject('CreateDataTable: Table ' + `${table.name} info does not exist`);
            }
            // Loop on Table Values
            for (let j = 0; j < table.values.length; j++) {
                let row = table.values[j];
                let isRun = true;
                const stmt = await this.createRowStatement(mDB, tableColumnNames, row, j, table.name, mode);
                isRun = await this.checkUpdate(mDB, stmt, row, table.name, tableColumnNames);
                if (isRun) {
                    if (stmt.substring(0, 6).toUpperCase() === 'DELETE') {
                        row = [];
                    }
                    lastId = await this.sqliteUtil.prepareRun(mDB, stmt, row, true);
                    if (lastId < 0) {
                        return Promise.reject('CreateDataTable: lastId < 0');
                    }
                }
                else {
                    lastId = 0;
                }
            }
            return Promise.resolve(lastId);
        }
        catch (err) {
            return Promise.reject(`CreateDataTable: ${err}`);
        }
    }
    /**
     * CreateRowStatement
     * @param mDB
     * @param tColNames
     * @param row
     * @param j
     * @param tableName
     * @param mode
     * @returns
     */
    async createRowStatement(mDB, tColNames, row, j, tableName, mode) {
        // Check the row number of columns
        if (row.length != tColNames.length ||
            row.length === 0 ||
            tColNames.length === 0) {
            return Promise.reject(new Error(`CreateRowStatement: Table ${tableName} ` +
                `values row ${j} not correct length`));
        }
        try {
            const retisIdExists = await this.isIdExists(mDB, tableName, tColNames[0], row[0]);
            let stmt;
            if (mode === 'full' || (mode === 'partial' && !retisIdExists)) {
                // Insert
                const nameString = tColNames.join();
                const questionMarkString = await this.createQuestionMarkString(tColNames.length);
                stmt = `INSERT INTO ${tableName} (${nameString}) VALUES (`;
                stmt += `${questionMarkString});`;
            }
            else {
                // Update or Delete
                let isUpdate = true;
                const isColDeleted = (element) => element === `sql_deleted`;
                const idxDelete = tColNames.findIndex(isColDeleted);
                if (idxDelete >= 0) {
                    if (row[idxDelete] === 1) {
                        isUpdate = false;
                        stmt = `DELETE FROM ${tableName} WHERE `;
                        if (typeof row[0] == 'string') {
                            stmt += `${tColNames[0]} = '${row[0]}';`;
                        }
                        else {
                            stmt += `${tColNames[0]} = ${row[0]};`;
                        }
                    }
                }
                if (isUpdate) {
                    // Update
                    const setString = await this.setNameForUpdate(tColNames);
                    if (setString.length === 0) {
                        return Promise.reject(new Error(`CreateRowStatement: Table ${tableName} ` +
                            `values row ${j} not set to String`));
                    }
                    stmt = `UPDATE ${tableName} SET ${setString} WHERE `;
                    if (typeof row[0] == 'string') {
                        stmt += `${tColNames[0]} = '${row[0]}';`;
                    }
                    else {
                        stmt += `${tColNames[0]} = ${row[0]};`;
                    }
                }
            }
            return Promise.resolve(stmt);
        }
        catch (err) {
            return Promise.reject(new Error(`CreateRowStatement: ${err.message}`));
        }
    }
    /**
     *
     * @param db
     * @param values
     * @param tbName
     * @param tColNames
     * @returns
     */
    async checkUpdate(db, stmt, values, tbName, tColNames) {
        const isRun = true;
        if (stmt.substring(0, 6) === 'UPDATE') {
            try {
                let query = `SELECT * FROM ${tbName} WHERE `;
                if (typeof values[0] == 'string') {
                    query += `${tColNames[0]} = '${values[0]}';`;
                }
                else {
                    query += `${tColNames[0]} = ${values[0]};`;
                }
                const resQuery = await this.getValues(db, query, tbName);
                let resValues = [];
                if (resQuery.length > 0) {
                    resValues = resQuery[0];
                }
                if (values.length > 0 &&
                    resValues.length > 0 &&
                    values.length === resValues.length) {
                    for (let i = 0; i < values.length; i++) {
                        if (values[i] !== resValues[i]) {
                            return Promise.resolve(true);
                        }
                    }
                    return Promise.resolve(false);
                }
                else {
                    const msg = 'Both arrays not the same length';
                    return Promise.reject(new Error(`CheckUpdate: ${msg}`));
                }
            }
            catch (err) {
                return Promise.reject(new Error(`CheckUpdate: ${err.message}`));
            }
        }
        else {
            return Promise.resolve(isRun);
        }
    }
    /**
     * GetValues
     * @param mDb
     * @param query
     * @param tableName
     */
    async getValues(mDb, query, tableName) {
        const values = [];
        try {
            // get table column names and types
            const tableNamesTypes = await this.sqliteUtil.getTableColumnNamesTypes(mDb, tableName);
            let rowNames = [];
            if (Object.keys(tableNamesTypes).includes('names')) {
                rowNames = tableNamesTypes.names;
            }
            else {
                return Promise.reject(`GetValues: Table ${tableName} no names`);
            }
            const retValues = await this.sqliteUtil.queryAll(mDb, query, []);
            for (const rValue of retValues) {
                const row = [];
                for (const rName of rowNames) {
                    if (Object.keys(rValue).includes(rName)) {
                        row.push(rValue[rName]);
                    }
                    else {
                        row.push('NULL');
                    }
                }
                values.push(row);
            }
            return Promise.resolve(values);
        }
        catch (err) {
            return Promise.reject(`GetValues: ${err}`);
        }
    }
    /**
     * CheckColumnTypes
     * @param tableTypes
     * @param rowValues
     */
    /*
    private async checkColumnTypes(
      tableTypes: any[],
      rowValues: any[],
    ): Promise<boolean> {
      const isType = true;
      for (let i = 0; i < rowValues.length; i++) {
        if (rowValues[i].toString().toUpperCase() != 'NULL') {
          try {
            await this.isType(tableTypes[i], rowValues[i]);
          } catch (err) {
            return Promise.reject(new Error('checkColumnTypes: Type not found'));
          }
        }
      }
      return Promise.resolve(isType);
    }
  */
    /**
     * IsType
     * @param type
     * @param value
     */
    /*
    private async isType(type: string, value: any): Promise<void> {
      let ret = false;
      if (type === 'NULL' && typeof value === 'object') ret = true;
      if (type === 'TEXT' && typeof value === 'string') ret = true;
      if (type === 'INTEGER' && typeof value === 'number') ret = true;
      if (type === 'REAL' && typeof value === 'number') ret = true;
      if (type === 'BLOB' && typeof value === 'string') ret = true;
      if (ret) {
        return Promise.resolve();
      } else {
        return Promise.reject(new Error('IsType: not a SQL Type'));
      }
    }
  */
    /**
     * IsIdExists
     * @param db
     * @param dbName
     * @param firstColumnName
     * @param key
     */
    async isIdExists(db, dbName, firstColumnName, key) {
        let ret = false;
        let query = `SELECT ${firstColumnName} FROM ` +
            `${dbName} WHERE ${firstColumnName} = `;
        if (typeof key === 'number')
            query += `${key};`;
        if (typeof key === 'string')
            query += `'${key}';`;
        try {
            const resQuery = await this.sqliteUtil.queryAll(db, query, []);
            if (resQuery.length === 1)
                ret = true;
            return Promise.resolve(ret);
        }
        catch (err) {
            return Promise.reject(`IsIdExists: ${err}`);
        }
    }
    /**
     * CreateQuestionMarkString
     * @param length
     */
    createQuestionMarkString(length) {
        return new Promise((resolve, reject) => {
            let retString = '';
            for (let i = 0; i < length; i++) {
                retString += '?,';
            }
            if (retString.length > 1) {
                retString = retString.slice(0, -1);
                resolve(retString);
            }
            else {
                reject('CreateQuestionMarkString: length = 0');
            }
        });
    }
    /**
     * SetNameForUpdate
     * @param names
     */
    async setNameForUpdate(names) {
        let retString = '';
        for (const name of names) {
            retString += `${name} = ? ,`;
        }
        if (retString.length > 1) {
            retString = retString.slice(0, -1);
            return Promise.resolve(retString);
        }
        else {
            return Promise.reject('SetNameForUpdate: length = 0');
        }
    }
    /**
     * IsJsonSQLite
     * @param obj
     */
    isJsonSQLite(obj) {
        const keyFirstLevel = [
            'database',
            'version',
            'overwrite',
            'encrypted',
            'mode',
            'tables',
            'views',
        ];
        if (obj == null ||
            (Object.keys(obj).length === 0 && obj.constructor === Object))
            return false;
        for (const key of Object.keys(obj)) {
            if (keyFirstLevel.indexOf(key) === -1)
                return false;
            if (key === 'database' && typeof obj[key] != 'string')
                return false;
            if (key === 'version' && typeof obj[key] != 'number')
                return false;
            if (key === 'overwrite' && typeof obj[key] != 'boolean')
                return false;
            if (key === 'encrypted' && typeof obj[key] != 'boolean')
                return false;
            if (key === 'mode' && typeof obj[key] != 'string')
                return false;
            if (key === 'tables' && typeof obj[key] != 'object')
                return false;
            if (key === 'tables') {
                for (const oKey of obj[key]) {
                    const retTable = this.isTable(oKey);
                    if (!retTable)
                        return false;
                }
            }
            if (key === 'views' && typeof obj[key] != 'object')
                return false;
            if (key === 'views') {
                for (const oKey of obj[key]) {
                    const retView = this.isView(oKey);
                    if (!retView)
                        return false;
                }
            }
        }
        return true;
    }
    /**
     * IsTable
     * @param obj
     */
    isTable(obj) {
        const keyTableLevel = [
            'name',
            'schema',
            'indexes',
            'triggers',
            'values',
        ];
        let nbColumn = 0;
        if (obj == null ||
            (Object.keys(obj).length === 0 && obj.constructor === Object))
            return false;
        for (const key of Object.keys(obj)) {
            if (keyTableLevel.indexOf(key) === -1)
                return false;
            if (key === 'name' && typeof obj[key] != 'string')
                return false;
            if (key === 'schema' && typeof obj[key] != 'object')
                return false;
            if (key === 'indexes' && typeof obj[key] != 'object')
                return false;
            if (key === 'triggers' && typeof obj[key] != 'object')
                return false;
            if (key === 'values' && typeof obj[key] != 'object')
                return false;
            if (key === 'schema') {
                obj['schema'].forEach((element) => {
                    if (element.column) {
                        nbColumn++;
                    }
                });
                for (let i = 0; i < nbColumn; i++) {
                    const retSchema = this.isSchema(obj[key][i]);
                    if (!retSchema)
                        return false;
                }
            }
            if (key === 'indexes') {
                for (const oKey of obj[key]) {
                    const retIndexes = this.isIndexes(oKey);
                    if (!retIndexes)
                        return false;
                }
            }
            if (key === 'triggers') {
                for (const oKey of obj[key]) {
                    const retTriggers = this.isTriggers(oKey);
                    if (!retTriggers)
                        return false;
                }
            }
            if (key === 'values') {
                if (nbColumn > 0) {
                    for (const oKey of obj[key]) {
                        if (typeof oKey != 'object' || oKey.length != nbColumn)
                            return false;
                    }
                }
            }
        }
        return true;
    }
    /**
     * IsSchema
     * @param obj
     */
    isSchema(obj) {
        const keySchemaLevel = [
            'column',
            'value',
            'foreignkey',
            'constraint',
        ];
        if (obj == null ||
            (Object.keys(obj).length === 0 && obj.constructor === Object))
            return false;
        for (const key of Object.keys(obj)) {
            if (keySchemaLevel.indexOf(key) === -1)
                return false;
            if (key === 'column' && typeof obj[key] != 'string')
                return false;
            if (key === 'value' && typeof obj[key] != 'string')
                return false;
            if (key === 'foreignkey' && typeof obj[key] != 'string')
                return false;
            if (key === 'constraint' && typeof obj[key] != 'string')
                return false;
        }
        return true;
    }
    /**
     * isIndexes
     * @param obj
     */
    isIndexes(obj) {
        const keyIndexesLevel = ['name', 'value', 'mode'];
        if (obj == null ||
            (Object.keys(obj).length === 0 && obj.constructor === Object))
            return false;
        for (const key of Object.keys(obj)) {
            if (keyIndexesLevel.indexOf(key) === -1)
                return false;
            if (key === 'name' && typeof obj[key] != 'string')
                return false;
            if (key === 'value' && typeof obj[key] != 'string')
                return false;
            if (key === 'mode' &&
                (typeof obj[key] != 'string' || obj[key].toUpperCase() != 'UNIQUE'))
                return false;
        }
        return true;
    }
    /**
     * isTriggers
     * @param obj
     */
    isTriggers(obj) {
        const keyTriggersLevel = [
            'name',
            'timeevent',
            'condition',
            'logic',
        ];
        if (obj == null ||
            (Object.keys(obj).length === 0 && obj.constructor === Object))
            return false;
        for (const key of Object.keys(obj)) {
            if (keyTriggersLevel.indexOf(key) === -1)
                return false;
            if (key === 'name' && typeof obj[key] != 'string')
                return false;
            if (key === 'timeevent' && typeof obj[key] != 'string')
                return false;
            if (key === 'condition' && typeof obj[key] != 'string')
                return false;
            if (key === 'logic' && typeof obj[key] != 'string')
                return false;
        }
        return true;
    }
    /**
     * IsViews
     * @param obj
     */
    isView(obj) {
        const keyViewLevel = ['name', 'value'];
        if (obj == null ||
            (Object.keys(obj).length === 0 && obj.constructor === Object))
            return false;
        for (const key of Object.keys(obj)) {
            if (keyViewLevel.indexOf(key) === -1)
                return false;
            if (key === 'name' && typeof obj[key] != 'string')
                return false;
            if (key === 'value' && typeof obj[key] != 'string')
                return false;
        }
        return true;
    }
    /**
     * checkSchemaValidity
     * @param schema
     */
    async checkSchemaValidity(schema) {
        for (let i = 0; i < schema.length; i++) {
            const sch = {};
            const keys = Object.keys(schema[i]);
            if (keys.includes('column')) {
                sch.column = schema[i].column;
            }
            if (keys.includes('value')) {
                sch.value = schema[i].value;
            }
            if (keys.includes('foreignkey')) {
                sch.foreignkey = schema[i].foreignkey;
            }
            if (keys.includes('constraint')) {
                sch.constraint = schema[i].constraint;
            }
            const isValid = this.isSchema(sch);
            if (!isValid) {
                return Promise.reject(`CheckSchemaValidity: schema[${i}] not valid`);
            }
        }
        return Promise.resolve();
    }
    /**
     * checkIndexesSchemaValidity
     * @param indexes
     */
    async checkIndexesValidity(indexes) {
        for (let i = 0; i < indexes.length; i++) {
            const index = {};
            const keys = Object.keys(indexes[i]);
            if (keys.includes('value')) {
                index.value = indexes[i].value;
            }
            if (keys.includes('name')) {
                index.name = indexes[i].name;
            }
            if (keys.includes('mode')) {
                index.mode = indexes[i].mode;
            }
            const isValid = this.isIndexes(index);
            if (!isValid) {
                return Promise.reject(`CheckIndexesValidity: indexes[${i}] not valid`);
            }
        }
        return Promise.resolve();
    }
    /**
     * checkTriggersValidity
     * @param triggers
     */
    async checkTriggersValidity(triggers) {
        for (let i = 0; i < triggers.length; i++) {
            const trigger = {};
            const keys = Object.keys(triggers[i]);
            if (keys.includes('logic')) {
                trigger.logic = triggers[i].logic;
            }
            if (keys.includes('name')) {
                trigger.name = triggers[i].name;
            }
            if (keys.includes('timeevent')) {
                trigger.timeevent = triggers[i].timeevent;
            }
            if (keys.includes('condition')) {
                trigger.condition = triggers[i].condition;
            }
            const isValid = this.isTriggers(trigger);
            if (!isValid) {
                return Promise.reject(`CheckTriggersValidity: triggers[${i}] not valid`);
            }
        }
        return Promise.resolve();
    }
    /**
     * checkViewsValidity
     * @param views
     */
    async checkViewsValidity(views) {
        for (let i = 0; i < views.length; i++) {
            const view = {};
            const keys = Object.keys(views[i]);
            if (keys.includes('value')) {
                view.value = views[i].value;
            }
            if (keys.includes('name')) {
                view.name = views[i].name;
            }
            const isValid = this.isView(view);
            if (!isValid) {
                return Promise.reject(`CheckViewsValidity: views[${i}] not valid`);
            }
        }
        return Promise.resolve();
    }
    /**
     * CreateView
     * @param mDB
     * @param table
     */
    async createView(mDB, view) {
        const stmt = `CREATE VIEW IF NOT EXISTS ${view.name} AS ${view.value};`;
        try {
            const changes = await this.sqliteUtil.execute(mDB, stmt, true);
            if (changes < 0) {
                return Promise.reject(`CreateView: ${view.name} failed`);
            }
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(`CreateView: ${err}`);
        }
    }
}
utilsJson.UtilsJson = UtilsJson;

Object.defineProperty(exportToJson, "__esModule", { value: true });
exportToJson.ExportToJson = void 0;
const utilsSQLite_1$4 = utilsSQLite;
const utilsJson_1$4 = utilsJson;
class ExportToJson {
    constructor() {
        this.sqliteUtil = new utilsSQLite_1$4.UtilsSQLite();
        this.jsonUtil = new utilsJson_1$4.UtilsJson();
    }
    /**
     * CreateExportObject
     * @param mDB
     * @param sqlObj
     */
    async createExportObject(mDB, sqlObj) {
        const retObj = {};
        let tables = [];
        let views = [];
        let errmsg = '';
        try {
            // get View's name
            views = await this.getViewsName(mDB);
            // get Table's name
            const resTables = await this.getTablesNameSQL(mDB);
            if (resTables.length === 0) {
                return Promise.reject("createExportObject: table's names failed");
            }
            else {
                const isTable = await this.jsonUtil.isTableExists(mDB, true, 'sync_table');
                if (!isTable && sqlObj.mode === 'partial') {
                    return Promise.reject('No sync_table available');
                }
                switch (sqlObj.mode) {
                    case 'partial': {
                        tables = await this.getTablesPartial(mDB, resTables);
                        break;
                    }
                    case 'full': {
                        tables = await this.getTablesFull(mDB, resTables);
                        break;
                    }
                    default: {
                        errmsg =
                            'createExportObject: expMode ' + sqlObj.mode + ' not defined';
                        break;
                    }
                }
                if (errmsg.length > 0) {
                    return Promise.reject(errmsg);
                }
                if (tables.length > 0) {
                    retObj.database = sqlObj.database;
                    retObj.version = sqlObj.version;
                    retObj.encrypted = sqlObj.encrypted;
                    retObj.mode = sqlObj.mode;
                    retObj.tables = tables;
                    if (views.length > 0) {
                        retObj.views = views;
                    }
                }
                return Promise.resolve(retObj);
            }
        }
        catch (err) {
            return Promise.reject('createExportObject: ' + err);
        }
    }
    /**
     * GetTablesNameSQL
     * @param mDb
     */
    async getTablesNameSQL(mDb) {
        let sql = 'SELECT name,sql FROM sqlite_master WHERE ';
        sql += "type='table' AND name NOT LIKE 'sync_table' ";
        sql += "AND name NOT LIKE '_temp_%' ";
        sql += "AND name NOT LIKE 'sqlite_%';";
        let retQuery = [];
        try {
            retQuery = await this.sqliteUtil.queryAll(mDb, sql, []);
            return Promise.resolve(retQuery);
        }
        catch (err) {
            return Promise.reject(`getTablesNameSQL: ${err}`);
        }
    }
    async getLastExportDate(mDb) {
        return new Promise((resolve, reject) => {
            let retDate = -1;
            // get the last sync date
            const stmt = `SELECT sync_date FROM sync_table WHERE id = 2;`;
            mDb.get(stmt, [], (err, row) => {
                // process the row here
                if (err) {
                    reject(`getLastExportDate: ${err.message}`);
                }
                else {
                    if (row != null) {
                        const key = Object.keys(row)[0];
                        retDate = row[key];
                    }
                    resolve(retDate);
                }
            });
        });
    }
    /**
     * SetLastExportDate
     * @param mDb
     * @param lastExportedDate
     * @returns
     */
    async setLastExportDate(mDb, lastExportedDate) {
        try {
            const isTable = await this.jsonUtil.isTableExists(mDb, true, 'sync_table');
            if (!isTable) {
                return Promise.reject(new Error('setLastExportDate: No sync_table available'));
            }
            const sDate = Math.round(new Date(lastExportedDate).getTime() / 1000);
            let stmt = '';
            if ((await this.getLastExportDate(mDb)) > 0) {
                stmt = `UPDATE sync_table SET sync_date = ${sDate} WHERE id = 2;`;
            }
            else {
                stmt = `INSERT INTO sync_table (sync_date) VALUES (${sDate});`;
            }
            const changes = await this.sqliteUtil.execute(mDb, stmt, false);
            if (changes < 0) {
                return { result: false, message: 'setLastExportDate failed' };
            }
            else {
                return { result: true };
            }
        }
        catch (err) {
            return {
                result: false,
                message: `setLastExportDate failed: ${err.message}`,
            };
        }
    }
    async delExportedRows(mDb) {
        let lastExportDate;
        try {
            // check if synchronization table exists
            const isTable = await this.jsonUtil.isTableExists(mDb, true, 'sync_table');
            if (!isTable) {
                return Promise.reject('DelExportedRows: No sync_table available');
            }
            // get the last export date
            lastExportDate = await this.getLastExportDate(mDb);
            if (lastExportDate < 0) {
                return Promise.reject('DelExportedRows: no last exported date available');
            }
            // get the table' name list
            const resTables = await this.sqliteUtil.getTablesNames(mDb);
            if (resTables.length === 0) {
                return Promise.reject("DelExportedRows: No table's names returned");
            }
            // Loop through the tables
            for (const table of resTables) {
                let lastId = -1;
                // define the delete statement
                const delStmt = `DELETE FROM ${table}
              WHERE sql_deleted = 1 AND last_modified < ${lastExportDate};`;
                lastId = await this.sqliteUtil.prepareRun(mDb, delStmt, [], true);
                if (lastId < 0) {
                    return Promise.reject('DelExportedRows: lastId < 0');
                }
            }
        }
        catch (err) {
            return Promise.reject(`DelExportedRows failed: ${err.message}`);
        }
    }
    /**
     * GetViewsNameSQL
     * @param mDb
     */
    async getViewsName(mDb) {
        const views = [];
        let sql = 'SELECT name,sql FROM sqlite_master WHERE ';
        sql += "type='view' AND name NOT LIKE 'sqlite_%';";
        let retQuery = [];
        try {
            retQuery = await this.sqliteUtil.queryAll(mDb, sql, []);
            for (const query of retQuery) {
                const view = {};
                view.name = query.name;
                view.value = query.sql.substring(query.sql.indexOf('AS ') + 3);
                views.push(view);
            }
            return Promise.resolve(views);
        }
        catch (err) {
            return Promise.reject(`getViewsName: ${err}`);
        }
    }
    /**
     * GetSyncDate
     * @param mDb
     */
    async getSyncDate(mDb) {
        return new Promise((resolve, reject) => {
            let retDate = -1;
            // get the last sync date
            const stmt = `SELECT sync_date FROM sync_table WHERE id = 1;`;
            mDb.get(stmt, [], (err, row) => {
                // process the row here
                if (err) {
                    reject(`GetSyncDate: ${err.message}`);
                }
                else {
                    if (row != null) {
                        const key = Object.keys(row)[0];
                        retDate = row[key];
                        resolve(retDate);
                    }
                    else {
                        reject(`GetSyncDate: no syncDate`);
                    }
                }
            });
        });
    }
    /**
     * GetTablesFull
     * @param mDb
     * @param resTables
     */
    async getTablesFull(mDb, resTables) {
        const tables = [];
        let errmsg = '';
        try {
            // Loop through the tables
            for (const rTable of resTables) {
                let tableName;
                let sqlStmt;
                if (rTable.name) {
                    tableName = rTable.name;
                }
                else {
                    errmsg = 'GetTablesFull: no name';
                    break;
                }
                if (rTable.sql) {
                    sqlStmt = rTable.sql;
                }
                else {
                    errmsg = 'GetTablesFull: no sql';
                    break;
                }
                const table = {};
                // create Table's Schema
                const schema = await this.getSchema(sqlStmt);
                if (schema.length === 0) {
                    errmsg = 'GetTablesFull: no Schema returned';
                    break;
                }
                // check schema validity
                await this.jsonUtil.checkSchemaValidity(schema);
                // create Table's indexes if any
                const indexes = await this.getIndexes(mDb, tableName);
                if (indexes.length > 0) {
                    // check indexes validity
                    await this.jsonUtil.checkIndexesValidity(indexes);
                }
                // create Table's triggers if any
                const triggers = await this.getTriggers(mDb, tableName);
                if (triggers.length > 0) {
                    // check triggers validity
                    await this.jsonUtil.checkTriggersValidity(triggers);
                }
                // create Table's Data
                const query = `SELECT * FROM ${tableName};`;
                const values = await this.jsonUtil.getValues(mDb, query, tableName);
                table.name = tableName;
                if (schema.length > 0) {
                    table.schema = schema;
                }
                else {
                    errmsg = `GetTablesFull: must contain schema`;
                    break;
                }
                if (indexes.length > 0) {
                    table.indexes = indexes;
                }
                if (triggers.length > 0) {
                    table.triggers = triggers;
                }
                if (values.length > 0) {
                    table.values = values;
                }
                if (Object.keys(table).length <= 1) {
                    errmsg = `GetTablesFull: table ${tableName} is not a jsonTable`;
                    break;
                }
                tables.push(table);
            }
            if (errmsg.length > 0) {
                return Promise.reject(errmsg);
            }
            return Promise.resolve(tables);
        }
        catch (err) {
            return Promise.reject(`GetTablesFull: ${err}`);
        }
    }
    /**
     * GetSchema
     * @param mDb
     * @param sqlStmt
     * @param tableName
     */
    async getSchema(sqlStmt /*,tableName: string,*/) {
        const schema = [];
        // take the substring between parenthesis
        const openPar = sqlStmt.indexOf('(');
        const closePar = sqlStmt.lastIndexOf(')');
        let sstr = sqlStmt.substring(openPar + 1, closePar);
        // check if there is other parenthesis and replace the ',' by ''
        try {
            sstr = await this.modEmbeddedParentheses(sstr);
            const sch = sstr.split(',');
            // for each element of the array split the
            // first word as key
            for (const sc of sch) {
                const row = [];
                const scht = sc.trim();
                row[0] = scht.substring(0, scht.indexOf(' '));
                row[1] = scht.substring(scht.indexOf(' ') + 1);
                const jsonRow = {};
                if (row[0].toUpperCase() === 'FOREIGN') {
                    const oPar = sc.indexOf('(');
                    const cPar = sc.indexOf(')');
                    row[0] = sc.substring(oPar + 1, cPar);
                    row[1] = sc.substring(cPar + 2);
                    jsonRow['foreignkey'] = row[0];
                }
                else if (row[0].toUpperCase() === 'CONSTRAINT') {
                    const tRow = [];
                    const row1t = row[1].trim();
                    tRow[0] = row1t.substring(0, row1t.indexOf(' '));
                    tRow[1] = row1t.substring(row1t.indexOf(' ') + 1);
                    row[0] = tRow[0];
                    jsonRow['constraint'] = row[0];
                    row[1] = tRow[1];
                }
                else {
                    jsonRow['column'] = row[0];
                }
                jsonRow['value'] = row[1].replace(//g, ',');
                schema.push(jsonRow);
            }
            return Promise.resolve(schema);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    /**
     * GetIndexes
     * @param mDb
     * @param sqlStmt
     * @param tableName
     */
    async getIndexes(mDb, tableName) {
        const indexes = [];
        let errmsg = '';
        try {
            let stmt = 'SELECT name,tbl_name,sql FROM sqlite_master WHERE ';
            stmt += `type = 'index' AND tbl_name = '${tableName}' `;
            stmt += `AND sql NOTNULL;`;
            const retIndexes = await this.sqliteUtil.queryAll(mDb, stmt, []);
            if (retIndexes.length > 0) {
                for (const rIndex of retIndexes) {
                    const keys = Object.keys(rIndex);
                    if (keys.length === 3) {
                        if (rIndex['tbl_name'] === tableName) {
                            const sql = rIndex['sql'];
                            const mode = sql.includes('UNIQUE') ? 'UNIQUE' : '';
                            const oPar = sql.lastIndexOf('(');
                            const cPar = sql.lastIndexOf(')');
                            const index = {};
                            index.name = rIndex['name'];
                            index.value = sql.slice(oPar + 1, cPar);
                            if (mode.length > 0)
                                index.mode = mode;
                            indexes.push(index);
                        }
                        else {
                            errmsg = `GetIndexes: Table ${tableName} doesn't match`;
                            break;
                        }
                    }
                    else {
                        errmsg = `GetIndexes: Table ${tableName} creating indexes`;
                        break;
                    }
                }
                if (errmsg.length > 0) {
                    return Promise.reject(errmsg);
                }
            }
            return Promise.resolve(indexes);
        }
        catch (err) {
            return Promise.reject(`GetIndexes: ${err}`);
        }
    }
    /**
     * GetTriggers
     * @param mDb
     * @param sqlStmt
     * @param tableName
     */
    async getTriggers(mDb, tableName) {
        const triggers = [];
        try {
            let stmt = 'SELECT name,tbl_name,sql FROM sqlite_master WHERE ';
            stmt += `type = 'trigger' AND tbl_name = '${tableName}' `;
            stmt += `AND sql NOT NULL;`;
            const retTriggers = await this.sqliteUtil.queryAll(mDb, stmt, []);
            if (retTriggers.length > 0) {
                for (const rTrg of retTriggers) {
                    const keys = Object.keys(rTrg);
                    if (keys.length === 3) {
                        if (rTrg['tbl_name'] === tableName) {
                            const sql = rTrg['sql'];
                            const name = rTrg['name'];
                            let sqlArr = sql.split(name);
                            if (sqlArr.length != 2) {
                                return Promise.reject(`GetTriggers: sql split name does not return 2 values`);
                            }
                            if (!sqlArr[1].includes(tableName)) {
                                return Promise.reject(`GetTriggers: sql split does not contains ${tableName}`);
                            }
                            const timeEvent = sqlArr[1].split(tableName, 1)[0].trim();
                            sqlArr = sqlArr[1].split(timeEvent + ' ' + tableName);
                            if (sqlArr.length != 2) {
                                return Promise.reject(`GetTriggers: sql split tableName does not return 2 values`);
                            }
                            let condition = '';
                            let logic = '';
                            if (sqlArr[1].trim().substring(0, 5).toUpperCase() !== 'BEGIN') {
                                sqlArr = sqlArr[1].trim().split('BEGIN');
                                if (sqlArr.length != 2) {
                                    return Promise.reject(`GetTriggers: sql split BEGIN does not return 2 values`);
                                }
                                condition = sqlArr[0].trim();
                                logic = 'BEGIN' + sqlArr[1];
                            }
                            else {
                                logic = sqlArr[1].trim();
                            }
                            const trigger = {};
                            trigger.name = name;
                            trigger.logic = logic;
                            if (condition.length > 0)
                                trigger.condition = condition;
                            trigger.timeevent = timeEvent;
                            triggers.push(trigger);
                        }
                        else {
                            return Promise.reject(`GetTriggers: Table ${tableName} doesn't match`);
                        }
                    }
                    else {
                        return Promise.reject(`GetTriggers: Table ${tableName} creating indexes`);
                    }
                }
            }
            return Promise.resolve(triggers);
        }
        catch (err) {
            return Promise.reject(`GetTriggers: ${err}`);
        }
    }
    /**
     * GetTablesPartial
     * @param mDb
     * @param resTables
     */
    async getTablesPartial(mDb, resTables) {
        const tables = [];
        let modTables = {};
        let syncDate = 0;
        let modTablesKeys = [];
        let errmsg = '';
        try {
            // Get the syncDate and the Modified Tables
            const partialModeData = await this.getPartialModeData(mDb, resTables);
            if (Object.keys(partialModeData).includes('syncDate')) {
                syncDate = partialModeData.syncDate;
            }
            if (Object.keys(partialModeData).includes('modTables')) {
                modTables = partialModeData.modTables;
                modTablesKeys = Object.keys(modTables);
            }
            // Loop trough tables
            for (const rTable of resTables) {
                let tableName = '';
                let sqlStmt = '';
                if (rTable.name) {
                    tableName = rTable.name;
                }
                else {
                    errmsg = 'GetTablesFull: no name';
                    break;
                }
                if (rTable.sql) {
                    sqlStmt = rTable.sql;
                }
                else {
                    errmsg = 'GetTablesFull: no sql';
                    break;
                }
                if (modTablesKeys.length == 0 ||
                    modTablesKeys.indexOf(tableName) === -1 ||
                    modTables[tableName] == 'No') {
                    continue;
                }
                const table = {};
                let schema = [];
                let indexes = [];
                let triggers = [];
                table.name = rTable;
                if (modTables[table.name] === 'Create') {
                    // create Table's Schema
                    schema = await this.getSchema(sqlStmt);
                    if (schema.length > 0) {
                        // check schema validity
                        await this.jsonUtil.checkSchemaValidity(schema);
                    }
                    // create Table's indexes if any
                    indexes = await this.getIndexes(mDb, tableName);
                    if (indexes.length > 0) {
                        // check indexes validity
                        await this.jsonUtil.checkIndexesValidity(indexes);
                    }
                    // create Table's triggers if any
                    triggers = await this.getTriggers(mDb, tableName);
                    if (triggers.length > 0) {
                        // check triggers validity
                        await this.jsonUtil.checkTriggersValidity(triggers);
                    }
                }
                // create Table's Data
                let query = '';
                if (modTables[tableName] === 'Create') {
                    query = `SELECT * FROM ${tableName};`;
                }
                else {
                    query =
                        `SELECT * FROM ${tableName} ` +
                            `WHERE last_modified > ${syncDate};`;
                }
                const values = await this.jsonUtil.getValues(mDb, query, tableName);
                // check the table object validity
                table.name = tableName;
                if (schema.length > 0) {
                    table.schema = schema;
                }
                if (indexes.length > 0) {
                    table.indexes = indexes;
                }
                if (triggers.length > 0) {
                    table.triggers = triggers;
                }
                if (values.length > 0) {
                    table.values = values;
                }
                if (Object.keys(table).length <= 1) {
                    errmsg = `GetTablesPartial: table ${tableName} is not a jsonTable`;
                    break;
                }
                tables.push(table);
            }
            if (errmsg.length > 0) {
                return Promise.reject(errmsg);
            }
            return Promise.resolve(tables);
        }
        catch (err) {
            return Promise.reject(`GetTablesPartial: ${err}`);
        }
    }
    /**
     * GetPartialModeData
     * @param mDb
     * @param resTables
     */
    async getPartialModeData(mDb, resTables) {
        const retData = {};
        try {
            // get the synchronization date
            const syncDate = await this.getSyncDate(mDb);
            if (syncDate <= 0) {
                return Promise.reject(`GetPartialModeData: no syncDate`);
            }
            // get the tables which have been updated
            // since last synchronization
            const modTables = await this.getTablesModified(mDb, resTables, syncDate);
            if (modTables.length <= 0) {
                return Promise.reject(`GetPartialModeData: no modTables`);
            }
            retData.syncDate = syncDate;
            retData.modTables = modTables;
            return Promise.resolve(retData);
        }
        catch (err) {
            return Promise.reject(`GetPartialModeData: ${err}`);
        }
    }
    async getTablesModified(db, tables, syncDate) {
        let errmsg = '';
        try {
            const retModified = {};
            for (const rTable of tables) {
                let mode;
                // get total count of the table
                let stmt = 'SELECT count(*) AS tcount  ';
                stmt += `FROM ${rTable.name};`;
                let retQuery = await this.sqliteUtil.queryAll(db, stmt, []);
                if (retQuery.length != 1) {
                    errmsg = 'GetTableModified: total ' + 'count not returned';
                    break;
                }
                const totalCount = retQuery[0]['tcount'];
                // get total count of modified since last sync
                stmt = 'SELECT count(*) AS mcount FROM ';
                stmt += `${rTable.name} WHERE last_modified > `;
                stmt += `${syncDate};`;
                retQuery = await this.sqliteUtil.queryAll(db, stmt, []);
                if (retQuery.length != 1)
                    break;
                const totalModifiedCount = retQuery[0]['mcount'];
                if (totalModifiedCount === 0) {
                    mode = 'No';
                }
                else if (totalCount === totalModifiedCount) {
                    mode = 'Create';
                }
                else {
                    mode = 'Modified';
                }
                const key = rTable.name;
                retModified[key] = mode;
            }
            if (errmsg.length > 0) {
                return Promise.reject(errmsg);
            }
            return Promise.resolve(retModified);
        }
        catch (err) {
            return Promise.reject(`GetTableModified: ${err}`);
        }
    }
    async modEmbeddedParentheses(sstr) {
        const oParArray = this.indexOfChar(sstr, '(');
        const cParArray = this.indexOfChar(sstr, ')');
        if (oParArray.length != cParArray.length) {
            return Promise.reject("ModEmbeddedParentheses: Not same number of '(' & ')'");
        }
        if (oParArray.length === 0) {
            return Promise.resolve(sstr);
        }
        let resStmt = sstr.substring(0, oParArray[0] - 1);
        for (let i = 0; i < oParArray.length; i++) {
            let str;
            if (i < oParArray.length - 1) {
                if (oParArray[i + 1] < cParArray[i]) {
                    str = sstr.substring(oParArray[i] - 1, cParArray[i + 1]);
                    i++;
                }
                else {
                    str = sstr.substring(oParArray[i] - 1, cParArray[i]);
                }
            }
            else {
                str = sstr.substring(oParArray[i] - 1, cParArray[i]);
            }
            const newS = str.replace(/,/g, '');
            resStmt += newS;
            if (i < oParArray.length - 1) {
                resStmt += sstr.substring(cParArray[i], oParArray[i + 1] - 1);
            }
        }
        resStmt += sstr.substring(cParArray[cParArray.length - 1], sstr.length);
        return Promise.resolve(resStmt);
    }
    indexOfChar(str, char) {
        const tmpArr = [...str];
        char = char.toLowerCase();
        return tmpArr.reduce((results, elem, idx) => elem.toLowerCase() === char ? [...results, idx] : results, []);
    }
}
exportToJson.ExportToJson = ExportToJson;

var importFromJson = {};

var utilsDrop = {};

Object.defineProperty(utilsDrop, "__esModule", { value: true });
utilsDrop.UtilsDrop = void 0;
const utilsSQLite_1$3 = utilsSQLite;
class UtilsDrop {
    constructor() {
        this.sqliteUtil = new utilsSQLite_1$3.UtilsSQLite();
    }
    /**
     * DropElements
     * @param db
     * @param type ["table","index","trigger"]
     */
    async dropElements(db, type) {
        let msg = '';
        let stmt1 = `AND name NOT LIKE ('sqlite_%')`;
        switch (type) {
            case 'index':
                msg = 'DropIndexes';
                break;
            case 'trigger':
                msg = 'DropTriggers';
                break;
            case 'table':
                msg = 'DropTables';
                stmt1 += ` AND name NOT IN ('sync_table')`;
                break;
            case 'view':
                msg = 'DropViews';
                break;
            default:
                return Promise.reject(`DropElements: ${type} ` + 'not found');
        }
        // get the element's names
        let stmt = 'SELECT name FROM sqlite_master WHERE ';
        stmt += `type = '${type}' ${stmt1};`;
        try {
            const elements = await this.sqliteUtil.queryAll(db, stmt, []);
            if (elements.length > 0) {
                const upType = type.toUpperCase();
                const statements = [];
                for (const elem of elements) {
                    let stmt = `DROP ${upType} IF EXISTS `;
                    stmt += `${elem.name};`;
                    statements.push(stmt);
                }
                for (const stmt of statements) {
                    const lastId = await this.sqliteUtil.prepareRun(db, stmt, [], false);
                    if (lastId < 0) {
                        return Promise.reject(`${msg}: lastId < 0`);
                    }
                }
            }
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(`${msg}: ${err}`);
        }
    }
    /**
     * DropAll
     * Drop all database's elements
     * @param db
     */
    async dropAll(db) {
        try {
            // drop tables
            await this.dropElements(db, 'table');
            // drop indexes
            await this.dropElements(db, 'index');
            // drop triggers
            await this.dropElements(db, 'trigger');
            // drop views
            await this.dropElements(db, 'view');
            // vacuum the database
            await this.sqliteUtil.prepareRun(db, 'VACUUM;', [], false);
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(`DropAll: ${err}`);
        }
    }
    /**
     * DropTempTables
     * @param db
     * @param alterTables
     */
    async dropTempTables(db, alterTables) {
        const tempTables = Object.keys(alterTables);
        const statements = [];
        for (const tTable of tempTables) {
            let stmt = 'DROP TABLE IF EXISTS ';
            stmt += `_temp_${tTable};`;
            statements.push(stmt);
        }
        try {
            const changes = await this.sqliteUtil.execute(db, statements.join('\n'), false);
            if (changes < 0) {
                return Promise.reject('DropTempTables: changes < 0');
            }
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(`DropTempTables: ${err}`);
        }
    }
}
utilsDrop.UtilsDrop = UtilsDrop;

Object.defineProperty(importFromJson, "__esModule", { value: true });
importFromJson.ImportFromJson = void 0;
const utilsDrop_1$1 = utilsDrop;
const utilsSQLite_1$2 = utilsSQLite;
const utilsJson_1$3 = utilsJson;
class ImportFromJson {
    constructor() {
        this.jsonUtil = new utilsJson_1$3.UtilsJson();
        this.sqliteUtil = new utilsSQLite_1$2.UtilsSQLite();
        this.dropUtil = new utilsDrop_1$1.UtilsDrop();
    }
    /**
     * CreateDatabaseSchema
     * @param mDB
     * @param jsonData
     */
    async createDatabaseSchema(mDB, jsonData) {
        let changes = -1;
        const version = jsonData.version;
        try {
            // set User Version PRAGMA
            await this.sqliteUtil.setVersion(mDB, version);
            // DROP ALL when mode="full"
            if (jsonData.mode === 'full') {
                await this.dropUtil.dropAll(mDB);
            }
            // create database schema
            changes = await this.jsonUtil.createSchema(mDB, jsonData);
            return Promise.resolve(changes);
        }
        catch (err) {
            return Promise.reject('CreateDatabaseSchema: ' + `${err}`);
        }
    }
    async createTablesData(mDB, jsonData) {
        let changes = 0;
        let isValue = false;
        let lastId = -1;
        let msg = '';
        let initChanges = -1;
        try {
            initChanges = await this.sqliteUtil.dbChanges(mDB);
            // start a transaction
            await this.sqliteUtil.beginTransaction(mDB, true);
        }
        catch (err) {
            return Promise.reject(`createTablesData: ${err}`);
        }
        for (const jTable of jsonData.tables) {
            if (jTable.values != null && jTable.values.length >= 1) {
                // Create the table's data
                try {
                    lastId = await this.jsonUtil.createDataTable(mDB, jTable, jsonData.mode);
                    if (lastId < 0)
                        break;
                    isValue = true;
                }
                catch (err) {
                    msg = err;
                    isValue = false;
                    break;
                }
            }
        }
        if (isValue) {
            try {
                await this.sqliteUtil.commitTransaction(mDB, true);
                changes = (await this.sqliteUtil.dbChanges(mDB)) - initChanges;
                return Promise.resolve(changes);
            }
            catch (err) {
                return Promise.reject('createTablesData: ' + `${err}`);
            }
        }
        else {
            if (msg.length > 0) {
                try {
                    await this.sqliteUtil.rollbackTransaction(mDB, true);
                    return Promise.reject(new Error(`createTablesData: ${msg}`));
                }
                catch (err) {
                    return Promise.reject('createTablesData: ' + `${err}: ${msg}`);
                }
            }
            else {
                // case were no values given
                return Promise.resolve(0);
            }
        }
    }
    /**
     * CreateViews
     * @param mDB
     * @param jsonData
     */
    async createViews(mDB, jsonData) {
        let isView = false;
        let msg = '';
        let initChanges = -1;
        let changes = -1;
        try {
            initChanges = await this.sqliteUtil.dbChanges(mDB);
            // start a transaction
            await this.sqliteUtil.beginTransaction(mDB, true);
        }
        catch (err) {
            return Promise.reject(`createViews: ${err}`);
        }
        for (const jView of jsonData.views) {
            if (jView.value != null) {
                // Create the view
                try {
                    await this.jsonUtil.createView(mDB, jView);
                    isView = true;
                }
                catch (err) {
                    msg = err;
                    isView = false;
                    break;
                }
            }
        }
        if (isView) {
            try {
                await this.sqliteUtil.commitTransaction(mDB, true);
                changes = (await this.sqliteUtil.dbChanges(mDB)) - initChanges;
                return Promise.resolve(changes);
            }
            catch (err) {
                return Promise.reject('createViews: ' + `${err}`);
            }
        }
        else {
            if (msg.length > 0) {
                try {
                    await this.sqliteUtil.rollbackTransaction(mDB, true);
                    return Promise.reject(new Error(`createViews: ${msg}`));
                }
                catch (err) {
                    return Promise.reject('createViews: ' + `${err}: ${msg}`);
                }
            }
            else {
                // case were no views given
                return Promise.resolve(0);
            }
        }
    }
}
importFromJson.ImportFromJson = ImportFromJson;

var utilsFile = {};

Object.defineProperty(utilsFile, "__esModule", { value: true });
utilsFile.UtilsFile = void 0;
class UtilsFile {
    constructor() {
        this.pathDB = 'Databases';
        this.Path = null;
        this.NodeFs = null;
        this.JSZip = null;
        this.Os = null;
        this.Electron = null;
        this.AppName = '';
        this.HomeDir = '';
        this.sep = '/';
        this.Path = require$$0__default$1['default'];
        this.NodeFs = require$$1__default['default'];
        this.Os = require$$2__default['default'];
        this.JSZip = require$$3__default['default'];
        this.Electron = require$$4__default['default'];
        this.HomeDir = this.Os.homedir();
        const dir = __dirname;
        const idx = dir.indexOf('\\');
        if (idx != -1)
            this.sep = '\\';
        this.appPath = this.Electron.app.getAppPath();
        const rawdata = this.NodeFs.readFileSync(this.Path.resolve(this.appPath, 'package.json'));
        this.AppName = JSON.parse(rawdata).name;
        const pathToBuild = this.Path.join(this.appPath, 'build');
        if (this.NodeFs.existsSync(this.Path.join(pathToBuild, 'capacitor.config.js'))) {
            // eslint-disable-next-line @typescript-eslint/no-var-requires
            this.capConfig = require(this.Path.join(pathToBuild, 'capacitor.config.js')).default;
        }
        else {
            this.capConfig = JSON.parse(this.NodeFs.readFileSync(this.Path.join(this.appPath, 'capacitor.config.json')).toString());
        }
        this.osType = this.Os.type();
        switch (this.osType) {
            case 'Darwin':
                this.pathDB = this.capConfig.plugins.CapacitorSQLite.electronMacLocation;
                break;
            case 'Linux':
                this.pathDB = this.capConfig.plugins.CapacitorSQLite.electronLinuxLocation;
                break;
            case 'Windows_NT':
                this.pathDB = this.capConfig.plugins.CapacitorSQLite.electronWindowsLocation;
                break;
            default:
                console.log('other operating system');
        }
        console.log(`&&& Databases path: ${this.pathDB}`);
    }
    /**
     * IsPathExists
     * @param filePath
     */
    isPathExists(filePath) {
        let ret = false;
        try {
            if (this.NodeFs.existsSync(filePath)) {
                ret = true;
            }
        }
        catch (err) {
            console.error('Error isFileExist: ' + err);
            ret = false;
        }
        return ret;
    }
    /**
     * IsFileExists
     * @param fileName
     */
    isFileExists(fileName) {
        let ret = false;
        const filePath = this.getFilePath(fileName);
        if (filePath.length > 0) {
            ret = this.isPathExists(filePath);
        }
        return ret;
    }
    /**
     * GetFilePath
     * get the file path
     * @param fileName
     */
    getFilePath(fileName) {
        return this.Path.join(this.getDatabasesPath(), fileName);
    }
    /**
     * GetDatabasesPath
     * get the database folder path
     */
    getDatabasesPath() {
        let retPath = '';
        const sep = this.Path.sep;
        const dbFolder = this.pathDB;
        if (dbFolder.includes(sep)) {
            retPath = dbFolder;
            if (this.Path.basename(dbFolder) !== this.AppName) {
                retPath = this.Path.join(dbFolder, this.AppName);
            }
        }
        else {
            retPath = this.Path.join(this.HomeDir, dbFolder, this.AppName);
        }
        const retB = this._createFolderIfNotExists(retPath);
        if (!retB)
            retPath = '';
        return retPath;
    }
    /**
     * GetAssetsDatabasesPath
     * get the assets databases folder path
     */
    getAssetsDatabasesPath() {
        let retPath = '';
        const rawdata = this.NodeFs.readFileSync(this.Path.resolve(this.appPath, 'capacitor.config.json'));
        const webDir = JSON.parse(rawdata).webDir;
        const dir = webDir === 'www' ? 'src' : 'public';
        retPath = this.Path.resolve(this.appPath, dir, 'assets', this.pathDB.toLowerCase());
        return retPath;
    }
    /**
     * SetPathSuffix
     * @param db
     */
    setPathSuffix(db) {
        let toDb = db;
        const ext = '.db';
        const sep = this.Path.sep;
        if (db.substring(db.length - 3) === ext) {
            if (!db.includes('SQLite.db')) {
                toDb = db.slice(db.lastIndexOf(sep) + 1, -3) + 'SQLite.db';
            }
        }
        return toDb;
    }
    /**
     * GetFileList
     * get the file list for a given folder
     * @param path
     */
    async getFileList(path) {
        const filenames = this.NodeFs.readdirSync(path);
        const dbs = [];
        filenames.forEach((file) => {
            if (this.Path.extname(file) == '.db' || this.Path.extname(file) == '.zip')
                dbs.push(file);
        });
        return Promise.resolve(dbs);
    }
    /**
     * CopyFromAssetToDatabase
     * @param db
     * @param overwrite
     */
    async copyFromAssetToDatabase(db, overwrite) {
        const pAsset = this.Path.join(this.getAssetsDatabasesPath(), db);
        const toDb = this.setPathSuffix(db);
        const pDb = this.Path.join(this.getDatabasesPath(), toDb);
        await this.copyFilePath(pAsset, pDb, overwrite);
        return Promise.resolve();
    }
    /**
     * unzipDatabase
     * @param db
     * @param overwrite
     */
    async unzipDatabase(db, overwrite) {
        const pZip = this.Path.join(this.getAssetsDatabasesPath(), db);
        // Read the Zip file
        this.NodeFs.readFile(pZip, (err, data) => {
            if (err) {
                console.log(err);
                return Promise.reject(`unzipDatabase ${JSON.stringify(err)}`);
            }
            const zip = new this.JSZip();
            zip.loadAsync(data).then((contents) => {
                Object.keys(contents.files).forEach(filename => {
                    zip
                        .file(filename)
                        .async('nodebuffer')
                        .then(async (content) => {
                        const toDb = this.setPathSuffix(filename);
                        const pDb = this.Path.join(this.getDatabasesPath(), toDb);
                        // check filePath exists
                        const isPath = this.isPathExists(pDb);
                        if (!isPath || overwrite) {
                            if (overwrite && isPath) {
                                await this.deleteFilePath(pDb);
                            }
                            this.NodeFs.writeFileSync(pDb, content);
                        }
                        return Promise.resolve();
                    });
                });
            });
        });
    }
    /**
     * CopyFileName
     * Copy file name
     * @param fileName
     * @param toFileName
     */
    async copyFileName(fileName, toFileName) {
        // get File Paths
        const filePath = this.getFilePath(fileName);
        const toFilePath = this.getFilePath(toFileName);
        if (filePath.length !== 0 && toFilePath.length !== 0) {
            try {
                await this.copyFilePath(filePath, toFilePath, true);
                return Promise.resolve();
            }
            catch (err) {
                return Promise.reject(`CopyFileName: ${err}`);
            }
        }
        else {
            return Promise.reject('CopyFileName: cannot get the ' + 'filePath');
        }
    }
    /**
     * CopyFilePath
     * Copy file Path
     * @param filePath
     * @param toFilePath
     */
    async copyFilePath(filePath, toFilePath, overwrite) {
        if (filePath.length !== 0 && toFilePath.length !== 0) {
            // check filePath exists
            const isPath = this.isPathExists(toFilePath);
            if (!isPath || overwrite) {
                try {
                    if (overwrite && isPath) {
                        await this.deleteFilePath(toFilePath);
                    }
                    this.NodeFs.copyFileSync(filePath, toFilePath);
                }
                catch (err) {
                    return Promise.reject(`CopyFilePath: ${err}`);
                }
            }
            return Promise.resolve();
        }
        else {
            return Promise.reject('CopyFilePath: cannot get the ' + 'filePath');
        }
    }
    async copyFile(fromPath, fromFile, toPath, toFile) {
        const fPath = this.Path.join(fromPath, fromFile);
        const tPath = this.Path.join(toPath, toFile);
        try {
            this.NodeFs.copyFileSync(fPath, tPath);
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(`CopyFile: ${err}`);
        }
    }
    /**
     * DeleteFileName
     * Delete a file by its name
     * @param fileName
     */
    async deleteFileName(fileName) {
        // get file path
        const filePath = this.getFilePath(fileName);
        if (filePath.length !== 0) {
            try {
                await this.deleteFilePath(filePath);
                return Promise.resolve();
            }
            catch (err) {
                return Promise.reject('DeleteFileName: delete filePath ' + `failed ${err}`);
            }
        }
        else {
            return Promise.reject('DeleteFileName: get filePath ' + 'failed');
        }
    }
    /**
     * DeleteFilePath
     * Delete a file by its path
     * @param filePath
     */
    async deleteFilePath(filePath) {
        if (filePath.length !== 0) {
            // check if path exists
            const isPath = this.isPathExists(filePath);
            if (isPath) {
                try {
                    this.NodeFs.unlinkSync(filePath);
                    return Promise.resolve();
                }
                catch (err) {
                    return Promise.reject('DeleteFilePath: ' + `${err}`);
                }
            }
            else {
                return Promise.resolve();
            }
        }
        else {
            return Promise.reject('DeleteFilePath: delete filePath' + 'failed');
        }
    }
    /**
     * RenameFileName
     * @param fileName
     * @param toFileName
     */
    async renameFileName(fileName, toFileName) {
        // get File Paths
        const filePath = this.getFilePath(fileName);
        const toFilePath = this.getFilePath(toFileName);
        if (filePath.length !== 0 && toFilePath.length !== 0) {
            try {
                await this.renameFilePath(filePath, toFilePath);
                return Promise.resolve();
            }
            catch (err) {
                return Promise.reject(`RenameFileName: ${err}`);
            }
        }
        else {
            return Promise.reject('RenameFileName: filePaths do not ' + 'exist');
        }
    }
    /**
     * RenameFilePath
     * @param filePath
     * @param toFilePath
     */
    async renameFilePath(filePath, toFilePath) {
        if (filePath.length !== 0 && toFilePath.length !== 0) {
            // check filePath exists
            const isPath = this.isPathExists(filePath);
            if (isPath) {
                // delete toFilePath if exists
                try {
                    await this.deleteFilePath(toFilePath);
                    this.NodeFs.renameSync(filePath, toFilePath);
                    return Promise.resolve();
                }
                catch (err) {
                    return Promise.reject('RenameFilePath: ' + `${err}`);
                }
            }
            else {
                return Promise.reject('RenameFilePath: filePath ' + 'does not exist');
            }
        }
        else {
            return Promise.reject('RenameFilePath: filePath not found');
        }
    }
    /**
     * RestoreFileName
     * @param fileName
     * @param prefix
     */
    async restoreFileName(fileName, prefix) {
        const mFileName = `${prefix}-${fileName}`;
        // check if file exists
        const isFilePre = this.isFileExists(mFileName);
        if (isFilePre) {
            const isFile = this.isFileExists(fileName);
            if (isFile) {
                try {
                    await this.deleteFileName(fileName);
                    await this.renameFileName(mFileName, fileName);
                    return Promise.resolve();
                }
                catch (err) {
                    return Promise.reject('RestoreFileName: ' + `${err}`);
                }
            }
            else {
                return Promise.reject(`RestoreFileName: ${fileName} ` + 'does not exist');
            }
        }
        else {
            return Promise.reject(`RestoreFileName: ${mFileName} ` + 'does not exist');
        }
    }
    /**
     * CreateFolderIfNotExists
     * Create directory
     * @param folder
     */
    _createFolderIfNotExists(folder) {
        let ret;
        try {
            if (!this.NodeFs.existsSync(folder)) {
                this._mkdirSyncRecursive(folder);
            }
            ret = true;
        }
        catch (e) {
            console.log('Error: in getDBPath', e);
            ret = false;
        }
        return ret;
    }
    /**
     * MkdirSyncRecursive
     * Create directories recursively
     * @param directory
     */
    _mkdirSyncRecursive(directory) {
        const sep = this.Path.sep;
        const path = directory.replace(/\/$/, '').split(sep);
        for (let i = 1; i <= path.length; i++) {
            const segment = path.slice(0, i).join(sep);
            segment.length > 0 && !this.NodeFs.existsSync(segment)
                ? this.NodeFs.mkdirSync(segment)
                : null;
        }
        return;
    }
}
utilsFile.UtilsFile = UtilsFile;

var utilsUpgrade = {};

Object.defineProperty(utilsUpgrade, "__esModule", { value: true });
utilsUpgrade.UtilsUpgrade = void 0;
const utilsJson_1$2 = utilsJson;
const utilsDrop_1 = utilsDrop;
const utilsFile_1$2 = utilsFile;
const utilsSQLite_1$1 = utilsSQLite;
class UtilsUpgrade {
    constructor() {
        this.sqliteUtil = new utilsSQLite_1$1.UtilsSQLite();
        this.fileUtil = new utilsFile_1$2.UtilsFile();
        this.dropUtil = new utilsDrop_1.UtilsDrop();
        this.jsonUtil = new utilsJson_1$2.UtilsJson();
        this._alterTables = {};
        this._commonColumns = {};
    }
    /**
     * OnUpgrade
     * @param mDB
     * @param vUpgDict
     * @param dbName
     * @param curVersion
     * @param targetVersion
     */
    async onUpgrade(mDB, vUpgDict, dbName, curVersion, targetVersion) {
        const upgrade = vUpgDict[curVersion];
        if (upgrade != null) {
            const keys = Object.keys(upgrade);
            if (!keys.includes('toVersion')) {
                return Promise.reject('onUpgrade: toVersion not given');
            }
            const toVersion = upgrade.toVersion;
            if (!keys.includes('statement')) {
                return Promise.reject('onUpgrade: statement not given');
            }
            const statement = upgrade.statement;
            let set = [];
            if (keys.includes('set')) {
                set = upgrade.set;
            }
            if (targetVersion < toVersion) {
                let msg = 'Error: version mistmatch ';
                msg += 'Upgrade Statement would upgrade to ';
                msg += `version ${toVersion} , but target version `;
                msg += `is ${targetVersion} for database ${dbName}`;
                msg += ` and version ${curVersion}`;
                return Promise.reject(`onUpgrade: ${msg}`);
            }
            try {
                // set Foreign Keys Off
                await this.sqliteUtil.setForeignKeyConstraintsEnabled(mDB, false);
                await this.fileUtil.copyFileName(dbName, `backup-${dbName}`);
                const initChanges = await this.sqliteUtil.dbChanges(mDB);
                // Here we assume that all table schemas are given
                // in the upgrade statement
                if (statement.length > 0) {
                    await this.executeStatementProcess(mDB, statement);
                    // Here we assume that the Set contains only
                    // - the data for new tables
                    //   as INSERT statements
                    // - the data for new columns in existing tables
                    //   as UPDATE statements
                    if (set.length > 0) {
                        await this.executeSetProcess(mDB, set, toVersion);
                    }
                }
                // set Foreign Keys On
                await this.sqliteUtil.setForeignKeyConstraintsEnabled(mDB, true);
                const changes = (await this.sqliteUtil.dbChanges(mDB)) - initChanges;
                return Promise.resolve(changes);
            }
            catch (err) {
                return Promise.reject(`onUpgrade: ${err}`);
            }
        }
        else {
            return Promise.reject('onUpgrade: upgrade not found');
        }
    }
    /**
     * ExecuteStatementProcess
     * @param mDB
     * @param statement
     */
    async executeStatementProcess(mDB, statement) {
        try {
            // -> backup all existing tables  "tableName" in
            //    "temp_tableName"
            await this.backupTables(mDB);
            // -> Drop all Indexes
            await this.dropUtil.dropElements(mDB, 'index');
            // -> Drop all Triggers
            await this.dropUtil.dropElements(mDB, 'trigger');
            // -> Create new tables from upgrade.statement
            const changes = await this.sqliteUtil.execute(mDB, statement, false);
            if (changes < 0) {
                return Promise.reject('ExecuteStatementProcess: ' + 'changes < 0');
            }
            // -> Create the list of table's common fields
            await this.findCommonColumns(mDB);
            // -> Update the new table's data from old table's data
            if (Object.keys(this._commonColumns).length > 0) {
                await this.updateNewTablesData(mDB);
            }
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(`ExecuteStatementProcess: ${err}`);
        }
        finally {
            // -> Drop _temp_tables
            await this.dropUtil.dropTempTables(mDB, this._alterTables);
            // -> Do some cleanup
            this._alterTables = {};
            this._commonColumns = {};
        }
    }
    /**
     * ExecuteSetProcess
     * @param mDB
     * @param set
     * @param toVersion
     */
    async executeSetProcess(mDB, set, toVersion) {
        try {
            // -> load new data
            const lastId = await this.sqliteUtil.executeSet(mDB, set, false);
            if (lastId < 0) {
                return Promise.reject('ExecuteSetProcess: lastId ' + '< 0');
            }
            // -> update database version
            await this.sqliteUtil.setVersion(mDB, toVersion);
            // -> update syncDate if any
            const retB = await this.jsonUtil.isTableExists(mDB, true, 'sync_table');
            if (retB) {
                const sDate = Math.round(new Date().getTime() / 1000);
                let stmt = 'UPDATE sync_table SET ';
                stmt += `sync_date = ${sDate} WHERE id = 1;`;
                const changes = await this.sqliteUtil.execute(mDB, stmt, false);
                if (changes < 0) {
                    return Promise.reject('ExecuteSetProcess: changes ' + '< 0');
                }
            }
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(`ExecuteSetProcess: ${err}`);
        }
    }
    /**
     * BackupTables
     * @param mDB
     */
    async backupTables(mDB) {
        const msg = 'BackupTables: ';
        try {
            const tables = await this.sqliteUtil.getTablesNames(mDB);
            for (const table of tables) {
                try {
                    await this.backupTable(mDB, table);
                }
                catch (err) {
                    return Promise.reject(`${msg}table ${table}: ` + `${err}`);
                }
            }
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(`BackupTables: ${err}`);
        }
    }
    /**
     * BackupTable
     * @param mDB
     * @param table
     */
    async backupTable(mDB, table) {
        try {
            // start a transaction
            await this.sqliteUtil.beginTransaction(mDB, true);
            // get the table's column names
            const colNames = await this.getTableColumnNames(mDB, table);
            this._alterTables[`${table}`] = colNames;
            const tmpTable = `_temp_${table}`;
            // Drop the tmpTable if exists
            const delStmt = `DROP TABLE IF EXISTS ${tmpTable};`;
            await this.sqliteUtil.prepareRun(mDB, delStmt, [], false);
            // prefix the table with _temp_
            let stmt = `ALTER TABLE ${table} RENAME `;
            stmt += `TO ${tmpTable};`;
            const lastId = await this.sqliteUtil.prepareRun(mDB, stmt, [], false);
            if (lastId < 0) {
                let msg = 'BackupTable: lastId < 0';
                try {
                    await this.sqliteUtil.rollbackTransaction(mDB, true);
                }
                catch (err) {
                    msg += `: ${err}`;
                }
                return Promise.reject(`${msg}`);
            }
            else {
                try {
                    await this.sqliteUtil.commitTransaction(mDB, true);
                }
                catch (err) {
                    return Promise.reject('BackupTable: ' + `${err}`);
                }
            }
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(`BackupTable: ${err}`);
        }
    }
    /**
     * GetTableColumnNames
     * @param mDB
     * @param tableName
     */
    async getTableColumnNames(mDB, tableName) {
        let resQuery = [];
        const retNames = [];
        const query = `PRAGMA table_info('${tableName}');`;
        try {
            resQuery = await this.sqliteUtil.queryAll(mDB, query, []);
            if (resQuery.length > 0) {
                for (const query of resQuery) {
                    retNames.push(query.name);
                }
            }
            return Promise.resolve(retNames);
        }
        catch (err) {
            return Promise.reject('GetTableColumnNames: ' + `${err}`);
        }
    }
    /**
     * FindCommonColumns
     * @param mDB
     */
    async findCommonColumns(mDB) {
        try {
            // Get new table list
            const tables = await this.sqliteUtil.getTablesNames(mDB);
            if (tables.length === 0) {
                return Promise.reject('FindCommonColumns: get ' + "table's names failed");
            }
            for (const table of tables) {
                // get the column's name
                const tableNames = await this.getTableColumnNames(mDB, table);
                // find the common columns
                const keys = Object.keys(this._alterTables);
                if (keys.includes(table)) {
                    this._commonColumns[table] = this.arraysIntersection(this._alterTables[table], tableNames);
                }
            }
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(`FindCommonColumns: ${err}`);
        }
    }
    /**
     * ArraysIntersection
     * @param a1
     * @param a2
     */
    arraysIntersection(a1, a2) {
        if (a1 != null && a2 != null) {
            const first = new Set(a1);
            const second = new Set(a2);
            return [...first].filter(item => second.has(item));
        }
        else {
            return [];
        }
    }
    /**
     * UpdateNewTablesData
     * @param mDB
     */
    async updateNewTablesData(mDB) {
        try {
            // start a transaction
            await this.sqliteUtil.beginTransaction(mDB, true);
            const statements = [];
            const keys = Object.keys(this._commonColumns);
            keys.forEach(key => {
                const columns = this._commonColumns[key].join(',');
                let stmt = `INSERT INTO ${key} `;
                stmt += `(${columns}) `;
                stmt += `SELECT ${columns} FROM _temp_${key};`;
                statements.push(stmt);
            });
            const changes = await this.sqliteUtil.execute(mDB, statements.join('\n'), false);
            if (changes < 0) {
                let msg = 'updateNewTablesData: ' + 'changes < 0';
                try {
                    await this.sqliteUtil.rollbackTransaction(mDB, true);
                }
                catch (err) {
                    msg += `: ${err}`;
                }
                return Promise.reject(`${msg}`);
            }
            else {
                try {
                    await this.sqliteUtil.commitTransaction(mDB, true);
                    return Promise.resolve();
                }
                catch (err) {
                    return Promise.reject('updateNewTablesData: ' + `${err}`);
                }
            }
        }
        catch (err) {
            return Promise.reject('updateNewTablesData: ' + `${err}`);
        }
    }
}
utilsUpgrade.UtilsUpgrade = UtilsUpgrade;

Object.defineProperty(Database$1, "__esModule", { value: true });
Database$1.Database = void 0;
const exportToJson_1 = exportToJson;
const importFromJson_1 = importFromJson;
const utilsJson_1$1 = utilsJson;
//import { UtilsEncryption } from './utilsEncryption';
const utilsFile_1$1 = utilsFile;
const utilsSQLite_1 = utilsSQLite;
const utilsUpgrade_1 = utilsUpgrade;
class Database {
    constructor(dbName, 
    //    encrypted: boolean,
    //    mode: string,
    version, upgDict) {
        this.fileUtil = new utilsFile_1$1.UtilsFile();
        this.sqliteUtil = new utilsSQLite_1.UtilsSQLite();
        this.jsonUtil = new utilsJson_1$1.UtilsJson();
        //  private _uGlobal: GlobalSQLite = new GlobalSQLite();
        //  private _uEncrypt: UtilsEncryption = new UtilsEncryption();
        this.upgradeUtil = new utilsUpgrade_1.UtilsUpgrade();
        this.importFromJsonUtil = new importFromJson_1.ImportFromJson();
        this.exportToJsonUtil = new exportToJson_1.ExportToJson();
        this.upgradeVersionDict = {};
        this.dbName = dbName;
        //    this._encrypted = encrypted;
        //    this._mode = mode;
        this.version = version;
        this.upgradeVersionDict = upgDict;
        this.pathDB = this.fileUtil.getFilePath(dbName);
        this._isDbOpen = false;
        if (this.pathDB.length === 0)
            throw new Error('Could not generate a path to ' + dbName);
    }
    /**
     * IsDBOpen
     * return the database status
     * @param options: capSQLiteOptions
     * @returns boolean
     * @since 0.0.1
     */
    isDBOpen() {
        return this._isDbOpen;
    }
    /**
     * Open
     * open the @journeyapps/sqlcipher sqlite3 database
     * @returns Promise<boolean>
     */
    async open() {
        this._isDbOpen = false;
        //    let password = '';
        try {
            /*
            if (
              this._encrypted &&
              (this._mode === 'secret' || this._mode === 'encryption')
            ) {
              password = this._uGlobal.secret;
            }
            if (this._mode === 'newsecret') {
              // change the password
              const oPassword: string = this._uGlobal.secret;
              const nPassword: string = this._uGlobal.newsecret;
              await this._uSQLite.changePassword(this._pathDB, oPassword, nPassword);
              password = nPassword;
            }
      
            if (this._mode === 'encryption') {
              await this._uEncrypt.encryptDatabase(this._pathDB, password);
            }
      */
            this.database = await this.sqliteUtil.openOrCreateDatabase(this.pathDB /*,
            password,*/);
            const curVersion = await this.sqliteUtil.getVersion(this.database);
            this._isDbOpen = true;
            if (this.version > curVersion &&
                Object.keys(this.upgradeVersionDict).length > 0) {
                try {
                    // execute the upgrade flow process
                    await this.upgradeUtil.onUpgrade(this.database, this.upgradeVersionDict, this.dbName, curVersion, this.version);
                    // delete the backup database
                    await this.fileUtil.deleteFileName(`backup-${this.dbName}`);
                }
                catch (err) {
                    // restore the database from backup
                    try {
                        await this.fileUtil.restoreFileName(this.dbName, 'backup');
                    }
                    catch (err) {
                        throw new Error(`Open: ${err}`);
                    }
                }
            }
            return;
        }
        catch (err) {
            if (this._isDbOpen)
                this.close();
            throw new Error(`Open: ${err}`);
        }
    }
    /**
     * Close
     * close the @journeyapps/sqlcipher sqlite3 database
     * @returns Promise<boolean>
     */
    async close() {
        this.ensureDatabaseIsOpen();
        this.database.close((err) => {
            if (err) {
                throw new Error('Close failed: ${this.dbName}  ${err}');
            }
            this._isDbOpen = false;
        });
    }
    /**
     * GetVersion
     * get the database version
     * @returns Promise<number>
     */
    async getVersion() {
        this.ensureDatabaseIsOpen();
        try {
            const currentVersion = await this.sqliteUtil.getVersion(this.database);
            return currentVersion;
        }
        catch (err) {
            if (this._isDbOpen)
                this.close();
            throw new Error(`getVersion: ${err}`);
        }
    }
    /**
     * DeleteDB
     * delete a database
     * @param dbName: string
     * @returns Promise<boolean>
     */
    async deleteDB(dbName) {
        // test if file exists
        const isExists = this.fileUtil.isFileExists(dbName);
        if (isExists && !this._isDbOpen) {
            // open the database
            try {
                await this.open();
            }
            catch (err) {
                throw new Error(`DeleteDB: ${err}`);
            }
        }
        // close the database
        try {
            await this.close();
        }
        catch (err) {
            throw new Error('DeleteDB: Close failed');
        }
        // delete the database
        if (isExists) {
            try {
                await this.fileUtil.deleteFileName(dbName);
            }
            catch (err) {
                throw new Error(`DeleteDB: deleteFile ${dbName} failed ${err}`);
            }
        }
        return;
    }
    /**
     * IsTableExists
     * @param tableName
     * @returns
     */
    async isTableExists(tableName) {
        this.ensureDatabaseIsOpen();
        const isOpen = this._isDbOpen;
        try {
            const tableExistsResult = await this.jsonUtil.isTableExists(this.database, isOpen, tableName);
            return tableExistsResult;
        }
        catch (err) {
            throw new Error(`IsTableExists: ${err}`);
        }
    }
    /**
     * CreateSyncTable
     * create the synchronization table
     * @returns Promise<number>
     */
    async createSyncTable() {
        this.ensureDatabaseIsOpen();
        let changes = -1;
        const isOpen = this._isDbOpen;
        // check if the table has already being created
        try {
            const retB = await this.jsonUtil.isTableExists(this.database, isOpen, 'sync_table');
            if (!retB) {
                const isLastModified = await this.sqliteUtil.isLastModified(this.database, isOpen);
                const isSqlDeleted = await this.sqliteUtil.isSqlDeleted(this.database, isOpen);
                if (isLastModified && isSqlDeleted) {
                    const date = Math.round(new Date().getTime() / 1000);
                    let stmts = `
                          CREATE TABLE IF NOT EXISTS sync_table (
                              id INTEGER PRIMARY KEY NOT NULL,
                              sync_date INTEGER
                              );`;
                    stmts += `INSERT INTO sync_table (sync_date) VALUES (
                              "${date}");`;
                    changes = await this.sqliteUtil.execute(this.database, stmts, false);
                    if (changes < 0) {
                        throw new Error(`CreateSyncTable: failed changes < 0`);
                    }
                }
                else {
                    throw new Error('No last_modified column in tables');
                }
            }
            else {
                changes = 0;
            }
            return changes;
        }
        catch (err) {
            throw new Error(`CreateSyncTable: ${err}`);
        }
    }
    /**
     * SetSyncDate
     * store the synchronization date
     * @param syncDate: string
     * @returns Promise<{result: boolean, message: string}>
     */
    async setSyncDate(syncDate) {
        this.ensureDatabaseIsOpen();
        try {
            const isTable = await this.jsonUtil.isTableExists(this.database, this._isDbOpen, 'sync_table');
            if (!isTable) {
                throw new Error('No sync_table available');
            }
            const syncDateUnixTimestamp = Math.round(new Date(syncDate).getTime() / 1000);
            let stmt = `UPDATE sync_table SET sync_date = `;
            stmt += `${syncDateUnixTimestamp} WHERE id = 1;`;
            const changes = await this.sqliteUtil.execute(this.database, stmt, false);
            if (changes < 0) {
                return { result: false, message: 'setSyncDate failed' };
            }
            else {
                return { result: true };
            }
        }
        catch (err) {
            return { result: false, message: `setSyncDate failed: ${err}` };
        }
    }
    /**
     * GetSyncDate
     * store the synchronization date
     * @returns Promise<{syncDate: number, message: string}>
     */
    async getSyncDate() {
        this.ensureDatabaseIsOpen();
        try {
            const isTable = await this.jsonUtil.isTableExists(this.database, this._isDbOpen, 'sync_table');
            if (!isTable) {
                throw new Error('No sync_table available');
            }
            const syncDate = await this.exportToJsonUtil.getSyncDate(this.database);
            if (syncDate > 0) {
                return { syncDate };
            }
            else {
                return { syncDate: 0, message: `setSyncDate failed` };
            }
        }
        catch (err) {
            return { syncDate: 0, message: `setSyncDate failed: ${err}` };
        }
    }
    /**
     * ExecuteSQL
     * execute raw sql statements store in a string
     * @param sql: string
     * @returns Promise<number>
     */
    async executeSQL(sql, transaction) {
        this.ensureDatabaseIsOpen();
        try {
            if (transaction) {
                await this.sqliteUtil.beginTransaction(this.database, this._isDbOpen);
            }
            const changes = await this.sqliteUtil.execute(this.database, sql, false);
            if (changes < 0) {
                throw new Error('ExecuteSQL: changes < 0');
            }
            if (transaction) {
                await this.sqliteUtil.commitTransaction(this.database, this._isDbOpen);
            }
            return changes;
        }
        catch (executeError) {
            let message = `${executeError}`;
            try {
                if (transaction) {
                    await this.sqliteUtil.rollbackTransaction(this.database, this._isDbOpen);
                }
            }
            catch (rollbackErr) {
                message += ` : ${rollbackErr}`;
            }
            throw new Error(`ExecuteSQL: ${message}`);
        }
    }
    /**
     * SelectSQL
     * execute a sql query with/without binding values
     * @param sql: string
     * @param values: string[]
     * @returns Promise<any[]>
     */
    async selectSQL(sql, values) {
        this.ensureDatabaseIsOpen();
        try {
            const selectResult = await this.sqliteUtil.queryAll(this.database, sql, values);
            return selectResult;
        }
        catch (err) {
            throw new Error(`SelectSQL: ${err}`);
        }
    }
    /**
     * runSQL
     * execute a raw sql statement with/without binding values
     * @param sql: string
     * @param values: string[]
     * @returns Promise<{changes:number, lastId:number}>
     */
    async runSQL(statement, values, transaction) {
        this.ensureDatabaseIsOpen();
        const result = { changes: -1, lastId: -1 };
        let initChanges = -1;
        try {
            initChanges = await this.sqliteUtil.dbChanges(this.database);
            // start a transaction
            if (transaction) {
                await this.sqliteUtil.beginTransaction(this.database, this._isDbOpen);
            }
        }
        catch (err) {
            throw new Error(`RunSQL: ${err}`);
        }
        try {
            const lastId = await this.sqliteUtil.prepareRun(this.database, statement, values, false);
            if (lastId < 0) {
                if (transaction) {
                    await this.sqliteUtil.rollbackTransaction(this.database, this._isDbOpen);
                }
                throw new Error(`RunSQL: return LastId < 0`);
            }
            if (transaction) {
                await this.sqliteUtil.commitTransaction(this.database, this._isDbOpen);
            }
            result.changes =
                (await this.sqliteUtil.dbChanges(this.database)) - initChanges;
            result.lastId = lastId;
            return result;
        }
        catch (err) {
            if (transaction) {
                await this.sqliteUtil.rollbackTransaction(this.database, this._isDbOpen);
            }
            throw new Error(`RunSQL: ${err}`);
        }
    }
    /**
     * ExecSet
     * execute a set of raw sql statements with/without binding values
     * @param set: any[]
     * @returns Promise<{changes:number, lastId:number}>
     */
    async execSet(set, transaction) {
        this.ensureDatabaseIsOpen();
        const result = { changes: -1, lastId: -1 };
        let initChanges = -1;
        try {
            initChanges = await this.sqliteUtil.dbChanges(this.database);
            // start a transaction
            if (transaction) {
                await this.sqliteUtil.beginTransaction(this.database, this._isDbOpen);
            }
        }
        catch (err) {
            throw new Error(`ExecSet: ${err}`);
        }
        try {
            result.lastId = await this.sqliteUtil.executeSet(this.database, set, false);
            if (transaction) {
                await this.sqliteUtil.commitTransaction(this.database, this._isDbOpen);
            }
            result.changes =
                (await this.sqliteUtil.dbChanges(this.database)) - initChanges;
            return result;
        }
        catch (err) {
            const message = err;
            try {
                if (transaction) {
                    await this.sqliteUtil.rollbackTransaction(this.database, this._isDbOpen);
                }
            }
            catch (err) {
                throw new Error(`ExecSet: ${message}: ` + `${err}`);
            }
        }
    }
    async deleteExportedRows() {
        this.ensureDatabaseIsOpen();
        try {
            await this.exportToJsonUtil.delExportedRows(this.database);
            return;
        }
        catch (err) {
            throw new Error(`DeleteExportedRows: ${err}`);
        }
    }
    /**
     * GetTableList
     * get the table's list
     * @returns
     */
    async getTableList() {
        this.ensureDatabaseIsOpen();
        try {
            const tableNames = await this.sqliteUtil.getTablesNames(this.database);
            return tableNames;
        }
        catch (err) {
            throw new Error(`GetTableList: ${err}`);
        }
    }
    async importJson(jsonData) {
        let changes = 0;
        this.ensureDatabaseIsOpen();
        try {
            // set Foreign Keys Off
            await this.sqliteUtil.setForeignKeyConstraintsEnabled(this.database, false);
            if (jsonData.tables && jsonData.tables.length > 0) {
                // create the database schema
                changes = await this.importFromJsonUtil.createDatabaseSchema(this.database, jsonData);
                if (changes != -1) {
                    // create the tables data
                    changes += await this.importFromJsonUtil.createTablesData(this.database, jsonData);
                }
            }
            if (jsonData.views && jsonData.views.length > 0) {
                // create the views
                changes += await this.importFromJsonUtil.createViews(this.database, jsonData);
            }
            // set Foreign Keys On
            await this.sqliteUtil.setForeignKeyConstraintsEnabled(this.database, true);
            return changes;
        }
        catch (err) {
            throw new Error(`ImportJson: ${err}`);
        }
    }
    async exportJson(mode) {
        const inJson = {};
        inJson.database = this.dbName.slice(0, -9);
        inJson.version = this.version;
        inJson.encrypted = false;
        inJson.mode = mode;
        this.ensureDatabaseIsOpen();
        try {
            await this.exportToJsonUtil.setLastExportDate(this.database, new Date().toISOString());
            const jsonResult = await this.exportToJsonUtil.createExportObject(this.database, inJson);
            const keys = Object.keys(jsonResult);
            if (keys.length === 0) {
                const msg = `ExportJson: return Object is empty ` + `No data to synchronize`;
                throw new Error(msg);
            }
            const isValid = this.jsonUtil.isJsonSQLite(jsonResult);
            if (isValid) {
                return jsonResult;
            }
            else {
                throw new Error(`ExportJson: retJson not valid`);
            }
        }
        catch (err) {
            throw new Error(`ExportJson: ${err}`);
        }
    }
    /**
     * Throws an error if `this._isDbOpen` is `false`.
     */
    ensureDatabaseIsOpen() {
        if (!this._isDbOpen || !this.database) {
            throw new Error(`getVersion: Database ${this.dbName} is not open yet. You should open it first.`);
        }
    }
}
Database$1.Database = Database;

Object.defineProperty(src, "__esModule", { value: true });
exports.CapacitorSQLite = src.CapacitorSQLite = void 0;
const Database_1 = Database$1;
const utilsJson_1 = utilsJson;
const utilsFile_1 = utilsFile;
class CapacitorSQLite {
    constructor() {
        this.versionUpgrades = {};
        this.databases = {};
        this.fileUtil = new utilsFile_1.UtilsFile();
        this.jsonUtil = new utilsJson_1.UtilsJson();
    }
    async createConnection(options) {
        const optionKeys = Object.keys(options);
        if (!optionKeys.includes('database')) {
            throw new Error('Must provide a database name');
        }
        const dbName = options.database;
        const version = options.version ? options.version : 1;
        /*    const encrypted = false;
        const inMode = "no-encryption";
    
        const encrypted: boolean =
          options.encrypted && this._osType === 'Darwin'
            ? options.encrypted
            : false;
        const inMode: string =
          options.mode && this._osType === 'Darwin'
            ? options.mode
            : 'no-encryption';
        */
        let upgrades = {};
        const versionUpgradeKeys = Object.keys(this.versionUpgrades);
        if (versionUpgradeKeys.length !== 0 &&
            versionUpgradeKeys.includes(dbName)) {
            upgrades = this.versionUpgrades[dbName];
        }
        const databaseConnection = new Database_1.Database(dbName + 'SQLite.db', 
        /*        encrypted,
        inMode,
        */
        version, upgrades);
        this.databases[dbName] = databaseConnection;
        return;
    }
    async closeConnection(options) {
        const dbName = this.getOptionValue(options, 'database');
        const database = this.getDatabaseConnectionOrThrowError(dbName);
        if (database.isDBOpen()) {
            // close the database
            try {
                await database.close();
            }
            catch (err) {
                throw new Error(`CloseConnection command failed:  close ${dbName} failed ${err.message}`);
            }
        }
        // remove the connection from dictionary
        delete this.databases[dbName];
    }
    async echo(options) {
        const echoValue = this.getOptionValue(options, 'value');
        const echoResult = {};
        echoResult.value = echoValue;
        return echoResult;
    }
    async open(options) {
        const dbName = this.getOptionValue(options, 'database');
        const database = this.getDatabaseConnectionOrThrowError(dbName);
        try {
            await database.open();
            return;
        }
        catch (err) {
            throw new Error(`Open: ${err}`);
        }
    }
    async close(options) {
        const dbName = this.getOptionValue(options, 'database');
        const database = this.getDatabaseConnectionOrThrowError(dbName);
        try {
            await database.close();
            return;
        }
        catch (err) {
            throw new Error(`Close: ${err}`);
        }
    }
    async getVersion(options) {
        const dbName = this.getOptionValue(options, 'database');
        const database = this.getDatabaseConnectionOrThrowError(dbName);
        try {
            const version = await database.getVersion();
            const versionResult = {};
            versionResult.version = version;
            return versionResult;
        }
        catch (err) {
            throw new Error(`GetVersion: ${err}`);
        }
    }
    async getTableList(options) {
        const dbName = this.getOptionValue(options, 'database');
        const database = this.getDatabaseConnectionOrThrowError(dbName);
        try {
            const tableList = await database.getTableList();
            const tableListResult = {};
            tableListResult.values = tableList;
            return tableListResult;
        }
        catch (err) {
            throw new Error(`GetTableList: ${err}`);
        }
    }
    async execute(options) {
        const dbName = this.getOptionValue(options, 'database');
        const statements = this.getOptionValue(options, 'statements');
        const transaction = this.getOptionValue(options, 'transaction', true);
        const database = this.getDatabaseConnectionOrThrowError(dbName);
        try {
            const executeResult = await database.executeSQL(statements, transaction);
            if (executeResult < 0) {
                throw new Error('Execute failed changes < 0');
            }
            else {
                return { changes: { changes: executeResult } };
            }
        }
        catch (err) {
            throw new Error(`Execute failed: ${err}`);
        }
    }
    async executeSet(options) {
        const dbName = this.getOptionValue(options, 'database');
        const setOfStatements = this.getOptionValue(options, 'set');
        const transaction = this.getOptionValue(options, 'transaction', true);
        const database = this.getDatabaseConnectionOrThrowError(dbName);
        for (const sStmt of setOfStatements) {
            if (!('statement' in sStmt) || !('values' in sStmt)) {
                throw new Error('ExecuteSet: Must provide a set as ' + 'Array of {statement,values}');
            }
        }
        try {
            const execSetResult = await database.execSet(setOfStatements, transaction);
            if (execSetResult < 0) {
                throw new Error(`ExecuteSet failed changes <0`);
            }
            else {
                return { changes: execSetResult };
            }
        }
        catch (err) {
            throw new Error(`ExecuteSet failed: ${err}`);
        }
    }
    async run(options) {
        const dbName = this.getOptionValue(options, 'database');
        const statement = this.getOptionValue(options, 'statement');
        const values = this.getOptionValue(options, 'values', []);
        const transaction = this.getOptionValue(options, 'transaction', true);
        const database = this.getDatabaseConnectionOrThrowError(dbName);
        try {
            const runResult = await database.runSQL(statement, values, transaction);
            return { changes: runResult };
        }
        catch (err) {
            throw new Error(`RUN failed: ${err} `);
        }
    }
    async query(options) {
        const dbName = this.getOptionValue(options, 'database');
        const statement = this.getOptionValue(options, 'statement');
        const values = this.getOptionValue(options, 'values', []);
        if (statement.length === 0) {
            throw new Error('Statement may not be an empty string.');
        }
        const database = this.getDatabaseConnectionOrThrowError(dbName);
        try {
            const queryResult = await database.selectSQL(statement, values);
            return { values: queryResult };
        }
        catch (err) {
            throw new Error(`Query failed: ${err}`);
        }
    }
    async isDBExists(options) {
        const dbName = this.getOptionValue(options, 'database');
        // Throw an error, if db connection is not opened yet:
        this.getDatabaseConnectionOrThrowError(dbName);
        const isExists = this.fileUtil.isFileExists(dbName + 'SQLite.db');
        return { result: isExists };
    }
    async isDBOpen(options) {
        const dbName = this.getOptionValue(options, 'database');
        const database = this.getDatabaseConnectionOrThrowError(dbName);
        const isOpen = await database.isDBOpen();
        return { result: isOpen };
    }
    async isDatabase(options) {
        const dbName = this.getOptionValue(options, 'database');
        const isExists = this.fileUtil.isFileExists(dbName + 'SQLite.db');
        return { result: isExists };
    }
    async isTableExists(options) {
        const dbName = this.getOptionValue(options, 'database');
        const tableName = this.getOptionValue(options, 'table');
        const database = this.getDatabaseConnectionOrThrowError(dbName);
        try {
            const isTableExistsResult = await database.isTableExists(tableName);
            return { result: isTableExistsResult };
        }
        catch (err) {
            throw new Error(`isTableExists: ${err}`);
        }
    }
    async deleteDatabase(options) {
        const dbName = this.getOptionValue(options, 'database');
        const database = this.getDatabaseConnectionOrThrowError(dbName);
        try {
            await database.deleteDB(dbName + 'SQLite.db');
            return;
        }
        catch (err) {
            throw new Error(`Delete: ${err}`);
        }
    }
    async isJsonValid(options) {
        const jsonString = this.getOptionValue(options, 'jsonstring');
        const jsonObj = JSON.parse(jsonString);
        const isValid = this.jsonUtil.isJsonSQLite(jsonObj);
        if (!isValid) {
            throw new Error('Stringify Json Object not Valid');
        }
        else {
            return { result: true };
        }
    }
    async importFromJson(options) {
        var _a, _b;
        const jsonString = this.getOptionValue(options, 'jsonstring');
        const jsonObj = JSON.parse(jsonString);
        const isValid = this.jsonUtil.isJsonSQLite(jsonObj);
        if (!isValid) {
            throw new Error('Must provide a valid JsonSQLite Object');
        }
        const vJsonObj = jsonObj;
        const dbName = `${vJsonObj.database}SQLite.db`;
        const targetDbVersion = (_a = vJsonObj.version) !== null && _a !== void 0 ? _a : 1;
        const mode = vJsonObj.mode;
        const overwrite = (_b = vJsonObj.overwrite) !== null && _b !== void 0 ? _b : false;
        //    const encrypted: boolean = vJsonObj.encrypted ?? false;
        //    const mode: string = encrypted ? 'secret' : 'no-encryption';
        // Create the database
        const database = new Database_1.Database(dbName, 
        /*encrypted, mode, */
        targetDbVersion, {});
        try {
            if (overwrite && mode === 'full') {
                const isExists = this.fileUtil.isFileExists(dbName);
                if (isExists) {
                    await this.fileUtil.deleteFileName(dbName);
                }
            }
            // Open the database
            await database.open();
            const tableList = await database.getTableList();
            if (mode === 'full' && tableList.length > 0) {
                const currentVersion = await database.getVersion();
                if (targetDbVersion < currentVersion) {
                    throw new Error(`ImportFromJson: Cannot import a version lower than ${currentVersion}`);
                }
                if (currentVersion === targetDbVersion) {
                    return { changes: { changes: 0 } };
                }
            }
            // Import the JsonSQLite Object
            const changes = await database.importJson(vJsonObj);
            // Close the database
            await database.close();
            return { changes: { changes: changes } };
        }
        catch (err) {
            throw new Error(`ImportFromJson: ${err}`);
        }
    }
    async exportToJson(options) {
        const dbName = this.getOptionValue(options, 'database');
        const exportMode = this.getOptionValue(options, 'jsonexportmode');
        const database = this.getDatabaseConnectionOrThrowError(dbName);
        try {
            const exportJsonResult = await database.exportJson(exportMode);
            const resultKeys = Object.keys(exportJsonResult);
            if (resultKeys.includes('message')) {
                throw new Error(`exportToJson: ${exportJsonResult.message}`);
            }
            else {
                return { export: exportJsonResult };
            }
        }
        catch (err) {
            throw new Error(`exportToJson: ${err}`);
        }
    }
    async createSyncTable(options) {
        const dbName = this.getOptionValue(options, 'database');
        const database = this.getDatabaseConnectionOrThrowError(dbName);
        try {
            const createTableSyncResult = await database.createSyncTable();
            return {
                changes: { changes: createTableSyncResult },
            };
        }
        catch (err) {
            throw new Error(`createSyncTable: ${err}`);
        }
    }
    async setSyncDate(options) {
        const dbName = this.getOptionValue(options, 'database');
        const syncDate = this.getOptionValue(options, 'syncdate');
        const database = this.getDatabaseConnectionOrThrowError(dbName);
        try {
            await database.setSyncDate(syncDate);
            return;
        }
        catch (err) {
            throw new Error(`SetSyncDate: ${err}`);
        }
    }
    async getSyncDate(options) {
        const dbName = this.getOptionValue(options, 'database');
        const database = this.getDatabaseConnectionOrThrowError(dbName);
        try {
            const ret = await database.getSyncDate();
            return Promise.resolve(ret);
        }
        catch (err) {
            throw new Error(`GetSyncDate: ${err}`);
        }
    }
    async deleteExportedRows(options) {
        const dbName = this.getOptionValue(options, 'database');
        const database = this.getDatabaseConnectionOrThrowError(dbName);
        try {
            await database.deleteExportedRows();
            return Promise.resolve();
        }
        catch (err) {
            throw new Error(`DeleteExportedRows: ${err}`);
        }
    }
    async addUpgradeStatement(options) {
        const dbName = this.getOptionValue(options, 'database');
        const upgrades = this.getOptionValue(options, 'upgrade');
        const firstUpgrade = upgrades[0];
        const versionUpgradeKeys = Object.keys(firstUpgrade);
        if (!versionUpgradeKeys.includes('fromVersion') ||
            !versionUpgradeKeys.includes('toVersion') ||
            !versionUpgradeKeys.includes('statement')) {
            throw new Error('Must provide an upgrade capSQLiteVersionUpgrade Object');
        }
        if (typeof firstUpgrade.fromVersion != 'number') {
            throw new Error('upgrade.fromVersion must be a number');
        }
        const upgradeVersionDict = {};
        upgradeVersionDict[firstUpgrade.fromVersion] = firstUpgrade;
        this.versionUpgrades[dbName] = upgradeVersionDict;
        return;
    }
    async copyFromAssets(options) {
        const overwrite = this.getOptionValue(options, 'overwrite', false);
        // check if the assets/database folder exists
        const assetsDbPath = this.fileUtil.getAssetsDatabasesPath();
        const pathExists = this.fileUtil.isPathExists(assetsDbPath);
        if (pathExists) {
            // get the database files
            const dbList = await this.fileUtil.getFileList(assetsDbPath);
            // loop through the database files
            dbList.forEach(async (db) => {
                if (db.substring(db.length - 3) === '.db') {
                    // for each copy the file to the Application database folder
                    await this.fileUtil.copyFromAssetToDatabase(db, overwrite);
                }
                if (db.substring(db.length - 4) === '.zip') {
                    await this.fileUtil.unzipDatabase(db, overwrite);
                }
            });
            return;
        }
        else {
            throw new Error('CopyFromAssets: assets/databases folder does not exist');
        }
    }
    async getDatabaseList() {
        // get the database folder
        const pathDatabase = this.fileUtil.getDatabasesPath();
        // get the list of databases
        const files = await this.fileUtil.getFileList(pathDatabase);
        if (files.length > 0) {
            return { values: files };
        }
        else {
            throw new Error(`isTableExists: No databases found`);
        }
    }
    async checkConnectionsConsistency(options) {
        const dbNames = this.getOptionValue(options, 'dbNames');
        const checkConsistencyResult = {};
        checkConsistencyResult.result = false;
        try {
            let inConnectionsSet = new Set(Object.keys(this.databases));
            const outConnectionSet = new Set(dbNames);
            if (outConnectionSet.size === 0) {
                await this.resetDbDict(Object.keys(this.databases));
                return Promise.resolve(checkConsistencyResult);
            }
            if (inConnectionsSet.size < outConnectionSet.size) {
                await this.resetDbDict(Object.keys(this.databases));
                return Promise.resolve(checkConsistencyResult);
            }
            if (inConnectionsSet.size > outConnectionSet.size) {
                for (const key of inConnectionsSet) {
                    if (!Array.from(outConnectionSet.keys()).includes(key)) {
                        const opt = {};
                        opt.database = key;
                        await this.closeConnection(opt);
                    }
                }
            }
            inConnectionsSet = new Set(Object.keys(this.databases));
            if (inConnectionsSet.size === outConnectionSet.size) {
                const symmetricDifferenceSet = await this.symmetricDifference(inConnectionsSet, outConnectionSet);
                if (symmetricDifferenceSet.size === 0) {
                    checkConsistencyResult.result = true;
                    return checkConsistencyResult;
                }
                else {
                    await this.resetDbDict(Object.keys(this.databases));
                    return checkConsistencyResult;
                }
            }
            else {
                await this.resetDbDict(Object.keys(this.databases));
                return checkConsistencyResult;
            }
        }
        catch (err) {
            throw new Error(`CheckConnectionsConsistency: ${err}`);
        }
    }
    async resetDbDict(keys) {
        try {
            for (const key of keys) {
                const opt = {};
                opt.database = key;
                await this.closeConnection(opt);
            }
        }
        catch (err) {
            throw new Error(`ResetDbDict: ${err}`);
        }
    }
    async symmetricDifference(setA, setB) {
        const difference = new Set(setA);
        for (const elem of setB) {
            if (difference.has(elem)) {
                difference.delete(elem);
            }
            else {
                difference.add(elem);
            }
        }
        return difference;
    }
    /**
     * Returns a database connection, if it already exists.
     * If the conneciton does not exist yet, it throws an error.
     *
     * @param dbName
     * @returns
     */
    getDatabaseConnectionOrThrowError(dbName) {
        const databaseNames = Object.keys(this.databases);
        if (!databaseNames.includes(dbName)) {
            throw new Error(`No connection available for database "${dbName}"`);
        }
        return this.databases[dbName];
    }
    /**
     * Gets the value of an option from the options object.
     * If the `optionKey` does not exist and there is no `defaultValue` defined, an exception is thrown.
     * If the `optionKey` does not exist but there is a `defaultValue`, the `defaultValue` is returned.
     *
     * @param options
     * @param optionKey
     * @param defaultValue
     * @returns
     */
    getOptionValue(options, optionKey, defaultValue = undefined) {
        const optionKeys = Object.keys(options);
        if (!optionKeys.includes(optionKey)) {
            if (defaultValue === undefined) {
                throw new Error(`Must provide "${optionKey}" in options.`);
            }
            else {
                return defaultValue;
            }
        }
        return options[optionKey];
    }
    ////////////////////////////////
    //// UNIMPLEMENTED METHODS
    ////////////////////////////////
    async getMigratableDbList(options) {
        console.log('getCordovaDbList', options);
        throw new Error('Method not implemented.');
    }
    async addSQLiteSuffix(options) {
        console.log(`${JSON.stringify(options)}`);
        throw new Error('Method not implemented.');
    }
    async deleteOldDatabases(options) {
        console.log(`${JSON.stringify(options)}`);
        throw new Error('Method not implemented.');
    }
    async getUrl() {
        throw new Error('Method not implemented.');
    }
    async initWebStore() {
        throw new Error('Method not implemented.');
    }
    async saveToStore(options) {
        console.log(`${JSON.stringify(options)}`);
        throw new Error('Method not implemented.');
    }
    async isSecretStored() {
        throw new Error('Method not implemented.');
    }
    async setEncryptionSecret(options) {
        console.log(`${JSON.stringify(options)}`);
        throw new Error('Method not implemented.');
    }
    async changeEncryptionSecret(options) {
        console.log(`${JSON.stringify(options)}`);
        throw new Error('Method not implemented.');
    }
    async clearEncryptionSecret() {
        console.log('clearEncryptionSecret');
        throw new Error('Method not implemented.');
    }
    async getNCDatabasePath(options) {
        console.log('getNCDatabasePath', options);
        throw new Error('Method not implemented.');
    }
    async createNCConnection(options) {
        console.log('createNCConnection', options);
        throw new Error('Method not implemented.');
    }
    async closeNCConnection(options) {
        console.log('closeNCConnection', options);
        throw new Error('Method not implemented.');
    }
    async isNCDatabase(options) {
        console.log('isNCDatabase', options);
        throw new Error('Method not implemented.');
    }
}
exports.CapacitorSQLite = src.CapacitorSQLite = CapacitorSQLite;

exports['default'] = src;
//# sourceMappingURL=plugin.js.map
